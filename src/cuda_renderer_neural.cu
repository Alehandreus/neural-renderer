#include "cuda_renderer_neural.h"

#include <cfloat>
#include <cmath>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <random>
#include <utility>

#include <cuda_fp16.h>

#include <tiny-cuda-nn/common_device.h>
#include <tiny-cuda-nn/gpu_matrix.h>
#include <tiny-cuda-nn/network_with_input_encoding.h>

#include "config_loader.h"
#include "scene.h"
#include "disney_brdf.cuh"
#include "mesh_intersection.cuh"
#include "hit_info.h"
#include "ray.h"
#include "render_params.h"
#include "mesh_traversal.cuh"

#ifdef USE_OPTIX
#include "rt/optix_state.h"
#include "rt/optix_launch_params.h"
#include <optix_stubs.h>   // optixLaunch and other host-side API wrappers
// Embedded PTX generated by CMake from src/rt/optix_programs.cu
#include "optix_programs_ptx.h"
#endif

namespace {

struct BoundingBox {
    Vec3 min;
    Vec3 max;
};

// Intersection mode for path tracing
enum IntersectionMode {
    GT_MESH,   // Ground truth mesh intersection
    NEURAL     // Neural network intersection
};

// Hit data structure returned by intersection kernels
struct HitData {
    bool hit;           // Whether ray hit anything
    Vec3 position;      // Hit position in world space
    Vec3 normal;        // Surface normal at hit point
    Vec3 albedo;        // Surface color/albedo (texture-modulated)
    Vec3 materialParams; // Material parameter triplet
    float distance;     // Distance to hit (for ray offsetting)
};

__device__ inline float clampf(float v, float lo, float hi) {
    return fminf(fmaxf(v, lo), hi);
}

__device__ inline Vec3 mul(Vec3 a, Vec3 b) {
    return Vec3(a.x * b.x, a.y * b.y, a.z * b.z);
}

__device__ inline float linearToSrgb(float v) {
    // Clamp to prevent negative values
    v = fmaxf(0.0f, v);

    // Apply correct sRGB formula
    float result;
    if (v <= 0.0031308f) {
        result = 12.92f * v;
    } else {
        result = 1.055f * powf(v, 1.0f / 2.4f) - 0.055f;
    }

    // Clamp output to [0, 1] range for display
    return fminf(1.0f, result);
}


__device__ inline Vec3 encodeSrgb(Vec3 c) {
    return Vec3(linearToSrgb(c.x), linearToSrgb(c.y), linearToSrgb(c.z));
}

__device__ inline Vec3 sampleEnvironment(EnvironmentDeviceView env, Vec3 dir) {
    if (env.pixels && env.width > 0 && env.height > 0) {
        // Apply rotation around Y axis
        if (env.rotation != 0.0f) {
            const float kDegToRad = 3.14159265358979323846f / 180.0f;
            float angle = env.rotation * kDegToRad;
            float cosA = cosf(angle);
            float sinA = sinf(angle);
            float newX = dir.x * cosA + dir.z * sinA;
            float newZ = -dir.x * sinA + dir.z * cosA;
            dir.x = newX;
            dir.z = newZ;
        }

        const float kInvTwoPi = 0.15915494309189535f;
        const float kInvPi = 0.3183098861837907f;
        float u = 0.5f + atan2f(dir.z, dir.x) * kInvTwoPi;
        float v = 0.5f - asinf(clampf(dir.y, -1.0f, 1.0f)) * kInvPi;
        u -= floorf(u);
        v = clampf(v, 0.0f, 1.0f);
        int x = static_cast<int>(u * static_cast<float>(env.width));
        int y = static_cast<int>(v * static_cast<float>(env.height));
        if (x >= env.width) {
            x = env.width - 1;
        }
        if (y >= env.height) {
            y = env.height - 1;
        }

        // Sample environment and apply strength
        Vec3 envColor = env.pixels[y * env.width + x] * env.strength;

        // Clamp to 100.0 to avoid fireflies from bright light sources (matching nbvh)
        envColor.x = fminf(envColor.x, 100.0f);
        envColor.y = fminf(envColor.y, 100.0f);
        envColor.z = fminf(envColor.z, 100.0f);

        return envColor;
    }

    Vec3 skyTop(0.2f, 0.4f, 0.7f);
    Vec3 skyBottom(0.8f, 0.9f, 1.0f);
    float skyT = 0.5f * (dir.y + 1.0f);
    return lerp(skyBottom, skyTop, skyT);
}

__device__ inline Vec3 clampRadiance(Vec3 c, float maxLum) {
    if (maxLum <= 0.0f) {
        return c;
    }
    float lum = 0.2126f * c.x + 0.7152f * c.y + 0.0722f * c.z;
    if (lum > maxLum) {
        float scale = maxLum / lum;
        return c * scale;
    }
    return c;
}

__device__ inline void buildTangentSpace(Vec3 normal, Vec3* tangent, Vec3* bitangent) {
    // Match NBVH's ortho_basis: pick most perpendicular cardinal axis
    Vec3 bitangent_init = Vec3(0.0f, 0.0f, 0.0f);

    if (normal.x < 0.6f && normal.x > -0.6f) {
        bitangent_init.x = 1.0f;
    } else if (normal.y < 0.6f && normal.y > -0.6f) {
        bitangent_init.y = 1.0f;
    } else if (normal.z < 0.6f && normal.z > -0.6f) {
        bitangent_init.z = 1.0f;
    } else {
        bitangent_init.x = 1.0f;
    }

    *tangent = normalize(cross(bitangent_init, normal));
    *bitangent = normalize(cross(normal, *tangent));
}

// Helper function: Sample environment map with radiance clamping
__forceinline__ __device__ Vec3 sampleEnvironmentWithClamp(EnvironmentDeviceView env,
                                                            Vec3 direction,
                                                            float maxRadiance) {
    Vec3 envLight = sampleEnvironment(env, direction);
    return Vec3(
        fminf(envLight.x, maxRadiance),
        fminf(envLight.y, maxRadiance),
        fminf(envLight.z, maxRadiance)
    );
}

// ---------------------------------------------------------------------------
// Unified Intersection Kernels
// ---------------------------------------------------------------------------

// Device function: Trace a single ray against GT mesh and return HitData
__forceinline__ __device__ HitData traceRayGT(const Ray& ray,
                                               MeshDeviceView mesh,
                                               const Material& globalMaterial) {
    HitData result;
    HitInfo hitInfo;
    bool hit = traceMesh(ray, mesh, &hitInfo, true, globalMaterial);

    result.hit = hit;
    if (hit) {
        result.position = hitInfo.position;
        result.normal = hitInfo.shadingNormal;

        // Resolve material at hit point
        const Material* mat = &globalMaterial;
        if (hitInfo.materialId >= 0 && hitInfo.materialId < mesh.numMaterials && mesh.materials) {
            mat = &mesh.materials[hitInfo.materialId];
        }
        ResolvedMaterial resolved = resolveMaterial(*mat, hitInfo.uv, mesh);

        result.albedo = resolved.base_color;
        // result.albedo = Vec3(1.0f, 1.0f, 1.0f);  // Use white albedo to isolate material param effects
        result.materialParams = Vec3(resolved.metallic, resolved.roughness, resolved.specular);
        // result.materialParams = Vec3(0.0, 0.0, 0.0);
        result.distance = hitInfo.t;
    } else {
        result.position = Vec3(0.0f, 0.0f, 0.0f);
        result.normal = Vec3(0.0f, 0.0f, 0.0f);
        result.albedo = Vec3(0.0f, 0.0f, 0.0f);
        result.distance = 0.0f;
    }

    return result;
}

// Device function: Unified ray intersection wrapper
// NOTE: Currently uses GT mesh for both modes. Neural inference for arbitrary rays
// would require significant architectural changes (batched host-side inference).
// For bounce rays, using GT mesh provides accurate lighting even in neural mode.
// Kernel: Intersect primary rays with ground truth mesh
__global__ void intersectGroundTruthKernel(float* hitPositions,
                                           float* hitNormals,
                                           float* hitColors,
                                           float* hitMaterialParams,
                                           int* hitFlags,
                                           RenderParams params,
                                           MeshDeviceView mesh) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) {
        return;
    }

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        int base = sampleIdx * 3;
        uint32_t rng = initRng(pixelIdx, params.sampleOffset, s);
        Ray ray = generatePrimaryRay(x, y, params, rng);

        HitData hit = traceRayGT(ray, mesh, params.material);

        if (hit.hit) {
            hitPositions[base + 0] = hit.position.x;
            hitPositions[base + 1] = hit.position.y;
            hitPositions[base + 2] = hit.position.z;
            hitNormals[base + 0] = hit.normal.x;
            hitNormals[base + 1] = hit.normal.y;
            hitNormals[base + 2] = hit.normal.z;
            hitColors[base + 0] = hit.albedo.x;
            hitColors[base + 1] = hit.albedo.y;
            hitColors[base + 2] = hit.albedo.z;
            hitMaterialParams[base + 0] = hit.materialParams.x;
            hitMaterialParams[base + 1] = hit.materialParams.y;
            hitMaterialParams[base + 2] = hit.materialParams.z;
            hitFlags[sampleIdx] = 1;
        } else {
            hitPositions[base + 0] = 0.0f;
            hitPositions[base + 1] = 0.0f;
            hitPositions[base + 2] = 0.0f;
            hitNormals[base + 0] = 0.0f;
            hitNormals[base + 1] = 0.0f;
            hitNormals[base + 2] = 0.0f;
            hitColors[base + 0] = 0.0f;
            hitColors[base + 1] = 0.0f;
            hitColors[base + 2] = 0.0f;
            hitMaterialParams[base + 0] = params.material.metallic.value;
            hitMaterialParams[base + 1] = params.material.roughness.value;
            hitMaterialParams[base + 2] = params.material.specular.value;
            hitFlags[sampleIdx] = 0;
        }
    }
}

// ---------------------------------------------------------------------------
// Wavefront Path Tracing Kernels (Shared between GT and Neural)
// ---------------------------------------------------------------------------

// Initialize path state from primary hits
__global__ void initializePathStateKernel(Vec3* throughput,
                                          Vec3* radiance,
                                          int* active,
                                          const int* hitFlags,
                                          const float* hitNormals,
                                          const float* hitColors,
                                          RenderParams params,
                                          EnvironmentDeviceView env) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) {
        return;
    }

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        uint32_t rng = initRng(pixelIdx, params.sampleOffset, s);
        Ray primaryRay = generatePrimaryRay(x, y, params, rng);

        Vec3 sampleRadiance(0.0f, 0.0f, 0.0f);
        Vec3 sampleThroughput(1.0f, 1.0f, 1.0f);
        int isActive = 0;

        if (hitFlags[sampleIdx]) {
            int base = sampleIdx * 3;
            Vec3 normal(hitNormals[base + 0], hitNormals[base + 1], hitNormals[base + 2]);
            float nlen = length(normal);
            if (nlen > 0.0f) {
                normal = normal / nlen;
            } else {
                normal = Vec3(0.0f, 1.0f, 0.0f);
            }
            if (dot(normal, primaryRay.direction) > 0.0f) {
                throughput[sampleIdx] = Vec3(0.0f, 0.0f, 0.0f);
                radiance[sampleIdx] = Vec3(0.0f, 0.0f, 0.0f);
                active[sampleIdx] = 0;
                continue;
            }
            // Initialize throughput to 1.0 (albedo is in BRDF)
            sampleThroughput = Vec3(1.0f, 1.0f, 1.0f);
            isActive = 1;
        } else {
            Vec3 envLight = sampleEnvironmentWithClamp(env, primaryRay.direction, params.maxRadiance);
            sampleRadiance = envLight;
        }

        throughput[sampleIdx] = sampleThroughput;
        radiance[sampleIdx] = sampleRadiance;
        active[sampleIdx] = isActive;
    }
}

// Sample bounce directions using Disney BRDF (shared kernel)
__global__ void sampleBounceDirectionsKernel(const float* hitPositions,
                                             const float* hitNormals,
                                             const float* hitColors,
                                             const float* hitMaterialParams,
                                             const int* hitFlags,
                                             const float* hitDistances,  // Input: neural distances from previous hit
                                             int* pathActive,
                                             RenderParams params,
                                             float* bounceOrigins,      // Output
                                             float* bounceDirections,   // Output
                                             float* bouncePdfs,         // Output
                                             float* bounceBRDFs,        // Output (f * cos / pdf)
                                             float* bounceDistances) {  // Output: pass through neural distances
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) {
        return;
    }

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        int base = sampleIdx * 3;

        if (!hitFlags[sampleIdx] || (pathActive && !pathActive[sampleIdx])) {
            bounceOrigins[base + 0] = 0.0f;
            bounceOrigins[base + 1] = 0.0f;
            bounceOrigins[base + 2] = 0.0f;
            bounceDirections[base + 0] = 0.0f;
            bounceDirections[base + 1] = 0.0f;
            bounceDirections[base + 2] = 0.0f;
            bouncePdfs[sampleIdx] = 0.0f;
            bounceBRDFs[base + 0] = 0.0f;
            bounceBRDFs[base + 1] = 0.0f;
            bounceBRDFs[base + 2] = 0.0f;
            if (bounceDistances) {
                bounceDistances[sampleIdx] = 0.0f;
            }
            continue;
        }

        uint32_t rng = initRng(pixelIdx, params.sampleOffset, s);
        Ray primaryRay = generatePrimaryRay(x, y, params, rng);

        Vec3 hitPos(hitPositions[base + 0], hitPositions[base + 1], hitPositions[base + 2]);
        Vec3 normal(hitNormals[base + 0], hitNormals[base + 1], hitNormals[base + 2]);
        Vec3 albedo(hitColors[base + 0], hitColors[base + 1], hitColors[base + 2]);

        // Normalize normal
        float nlen = length(normal);
        if (nlen > 0.0f) {
            normal = normal / nlen;
        } else {
            normal = Vec3(0.0f, 1.0f, 0.0f);
        }

        // Check for back-facing hit
        if (dot(normal, primaryRay.direction) > 0.0f) {
            if (pathActive) pathActive[sampleIdx] = 0;
            bouncePdfs[sampleIdx] = 0.0f;
            continue;
        }

        // Sample Disney BRDF for bounce direction
        Vec3 wo = primaryRay.direction * -1.0f;

        // Build tangent space
        Vec3 tangent, bitangent;
        buildTangentSpace(normal, &tangent, &bitangent);

        Vec3 materialParams(params.material.metallic.value, params.material.roughness.value, params.material.specular.value);
        if (hitMaterialParams) {
            materialParams.x = hitMaterialParams[base + 0];
            materialParams.y = hitMaterialParams[base + 1];
            materialParams.z = hitMaterialParams[base + 2];
        }

        // Create material with texture-modulated base color
        Material surfaceMat = params.material;
        surfaceMat.base_color = MaterialParamVec3::constant(albedo);
        surfaceMat.metallic = MaterialParam::constant(materialParams.x);
        surfaceMat.roughness = MaterialParam::constant(materialParams.y);
        surfaceMat.specular = MaterialParam::constant(materialParams.z);

        // Generate random numbers for BRDF sampling
        float u1 = rand01(rng);
        float u2 = rand01(rng);
        float u3 = rand01(rng);
        float pdf;
        // Use new 3-component sampler (diffuse, specular, clearcoat)
        Vec3 wi = disney_sample_3component(surfaceMat, normal, wo, tangent, bitangent,
                                           u1, u2, u3, &pdf);

        if (pdf <= 0.0f) {
            if (pathActive) pathActive[sampleIdx] = 0;
            bouncePdfs[sampleIdx] = 0.0f;
            continue;
        }

        // Evaluate Disney BRDF
        Vec3 f = disney_eval(surfaceMat, normal, wo, wi, tangent, bitangent);

        // Compute BRDF weight (f * cos / pdf)
        // Use fabs to match NBVH - handles numerical errors at grazing angles
        float cos_theta = fabsf(dot(normal, wi));
        Vec3 brdfWeight = f * (cos_theta / pdf);

        // Safety check for numerical issues
        if (isnan(brdfWeight.x) || isnan(brdfWeight.y) || isnan(brdfWeight.z) ||
            isinf(brdfWeight.x) || isinf(brdfWeight.y) || isinf(brdfWeight.z)) {
            if (pathActive) pathActive[sampleIdx] = 0;
            bouncePdfs[sampleIdx] = 0.0f;
            continue;
        }

        // Output bounce ray
        float rayOffset = params.sceneScale * 1e-6f;
        Vec3 origin = hitPos + normal * rayOffset;

        bounceOrigins[base + 0] = origin.x;
        bounceOrigins[base + 1] = origin.y;
        bounceOrigins[base + 2] = origin.z;
        bounceDirections[base + 0] = wi.x;
        bounceDirections[base + 1] = wi.y;
        bounceDirections[base + 2] = wi.z;
        bouncePdfs[sampleIdx] = pdf;
        bounceBRDFs[base + 0] = brdfWeight.x;
        bounceBRDFs[base + 1] = brdfWeight.y;
        bounceBRDFs[base + 2] = brdfWeight.z;

        // Pass through neural distance from the hit that created this bounce
        if (bounceDistances && hitDistances) {
            bounceDistances[sampleIdx] = hitDistances[sampleIdx];
        }
    }
}

// Check if bounce rays should terminate early based on neural distance
// This runs BEFORE tracing to avoid unnecessary work
__global__ void checkBounceEarlyTerminationKernel(
        const float* bounceOrigins,
        const float* bounceDirections,
        const float* bouncePdfs,
        const float* bounceDistances,
        int* pathActive,
        RenderParams params,
        MeshDeviceView outerShell,
        MeshDeviceView innerShell) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) {
        return;
    }

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        int base = sampleIdx * 3;

        // Skip if ray already inactive or has invalid PDF
        if (pathActive && !pathActive[sampleIdx]) {
            continue;
        }
        if (bouncePdfs && bouncePdfs[sampleIdx] <= 0.0f) {
            continue;
        }

        // Skip if no neural distance available
        if (!bounceDistances || bounceDistances[sampleIdx] <= 0.0f) {
            continue;
        }

        Vec3 origin(bounceOrigins[base + 0], bounceOrigins[base + 1], bounceOrigins[base + 2]);
        Vec3 dir(bounceDirections[base + 0], bounceDirections[base + 1], bounceDirections[base + 2]);
        Ray ray(origin, dir);

        HitInfo outerHit;
        bool hitOuter = traceMeshWithMode(ray, outerShell, &outerHit, TraceMode::ANY, false, params.material);

        HitInfo innerHit;
        bool hitInner = traceMeshWithMode(ray, innerShell, &innerHit, TraceMode::ANY, false, params.material);

        // if (hitInner && hitOuter && (innerHit.t < outerHit.t) && (outerHit.t > 0.01)) {
        //     if (pathActive) {
        //         pathActive[sampleIdx] = 0;
        //     }
        // }

        // If no forward hit, ray is inside the outer shell
        // if (!hitOuter) {
        //     // Find the exit point
        //     HitInfo exitHit;
        //     bool hitExit = traceMeshWithMode(ray, outerShell, &exitHit, TraceMode::BACKWARD_ONLY, false, params.material);

        //     if (hitExit) {
        //         float neuralDist = bounceDistances[sampleIdx];

        //         // If neural distance is less than exit distance, surface exists before exit
        //         // Terminate the ray - it already hit the neural surface
        //         if (exitHit.t > neuralDist * 100) {
        //             if (pathActive) {
        //                 pathActive[sampleIdx] = 0;
        //             }
        //         }
        //     }
        // }
    }
}

// Trace bounce rays against GT mesh (GT mode only)
__global__ void traceGroundTruthBouncesKernel(const float* bounceOrigins,
                                              const float* bounceDirections,
                                              const float* bouncePdfs,
                                              MeshDeviceView mesh,
                                              RenderParams params,
                                              float* bounceHitPositions,    // Output
                                              float* bounceHitNormals,      // Output
                                              float* bounceHitColors,       // Output
                                              float* bounceMaterialParams,  // Output
                                              int* bounceHitFlags) {        // Output
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) {
        return;
    }

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        int base = sampleIdx * 3;

        if (bouncePdfs[sampleIdx] <= 0.0f) {
            bounceHitFlags[sampleIdx] = 0;
            continue;
        }

        Vec3 origin(bounceOrigins[base + 0], bounceOrigins[base + 1], bounceOrigins[base + 2]);
        Vec3 direction(bounceDirections[base + 0], bounceDirections[base + 1], bounceDirections[base + 2]);
        Ray bounceRay(origin, direction);

        HitInfo hitInfo;
        bool hit = traceMesh(bounceRay, mesh, &hitInfo, true, params.material);

        if (hit) {
            bounceHitPositions[base + 0] = hitInfo.position.x;
            bounceHitPositions[base + 1] = hitInfo.position.y;
            bounceHitPositions[base + 2] = hitInfo.position.z;
            bounceHitNormals[base + 0] = hitInfo.shadingNormal.x;
            bounceHitNormals[base + 1] = hitInfo.shadingNormal.y;
            bounceHitNormals[base + 2] = hitInfo.shadingNormal.z;

            // Resolve material at hit point
            const Material* mat = &params.material;
            if (hitInfo.materialId >= 0 && hitInfo.materialId < mesh.numMaterials && mesh.materials) {
                mat = &mesh.materials[hitInfo.materialId];
            }
            ResolvedMaterial resolved = resolveMaterial(*mat, hitInfo.uv, mesh);

            bounceHitColors[base + 0] = resolved.base_color.x;
            bounceHitColors[base + 1] = resolved.base_color.y;
            bounceHitColors[base + 2] = resolved.base_color.z;
            bounceMaterialParams[base + 0] = resolved.metallic;
            bounceMaterialParams[base + 1] = resolved.roughness;
            bounceMaterialParams[base + 2] = resolved.specular;
            bounceHitFlags[sampleIdx] = 1;
        } else {
            bounceHitFlags[sampleIdx] = 0;
            bounceMaterialParams[base + 0] = params.material.metallic.value;
            bounceMaterialParams[base + 1] = params.material.roughness.value;
            bounceMaterialParams[base + 2] = params.material.specular.value;
        }
    }
}

// Integrate bounce results and update path state (shared kernel)
__global__ void integrateBounceKernel(Vec3* throughput,
                                      Vec3* radiance,
                                      int* active,
                                      const int* bounceHitFlags,
                                      const float* bounceDirections,
                                      const float* bounceBRDFs,
                                      int bounceIndex,
                                      RenderParams params,
                                      EnvironmentDeviceView env) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) {
        return;
    }

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        if (!active[sampleIdx]) {
            continue;
        }

        int base = sampleIdx * 3;
        Vec3 brdfWeight(bounceBRDFs[base + 0], bounceBRDFs[base + 1], bounceBRDFs[base + 2]);
        Vec3 newThroughput = mul(throughput[sampleIdx], brdfWeight);
        throughput[sampleIdx] = newThroughput;

        if (!bounceHitFlags[sampleIdx]) {
            // Ray missed - sample environment and terminate
            Vec3 envDir(bounceDirections[base + 0], bounceDirections[base + 1], bounceDirections[base + 2]);
            Vec3 envLight = sampleEnvironmentWithClamp(env, envDir, params.maxRadiance);
            radiance[sampleIdx] = radiance[sampleIdx] + mul(newThroughput, envLight);
            active[sampleIdx] = 0;
            continue;
        }

        if (bounceIndex >= params.maxBounces) {
            active[sampleIdx] = 0;
            continue;
        }

        // Russian roulette path termination (after 3 bounces)
        if (bounceIndex > 3) {
            Vec3 tp = throughput[sampleIdx];
            float q = fmaxf(0.05f, 1.0f - fmaxf(tp.x, fmaxf(tp.y, tp.z)));
            uint32_t rng = initRng(pixelIdx, params.sampleOffset + bounceIndex, s);
            if (rand01(rng) < q) {
                active[sampleIdx] = 0;
                continue;
            }
            throughput[sampleIdx] = tp * (1.0f / (1.0f - q));
        }
    }
}

// ---------------------------------------------------------------------------
// Trace hybrid bounces: check both shells and additional mesh (two-box early culling)
// ---------------------------------------------------------------------------
__global__ void traceHybridBouncesKernel(
        const float* bounceOrigins,
        const float* bounceDirections,
        const float* bouncePdfs,
        MeshDeviceView outerShell,
        MeshDeviceView additionalMesh,
        BoundingBox shellsBounds,
        BoundingBox additionalBounds,
        RenderParams params,
        float* bouncePositions,
        float* bounceNormals,
        float* bounceColors,
        int* bounceHitFlags) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) return;

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        int base = sampleIdx * 3;

        // Reconstruct bounce ray
        Vec3 origin(bounceOrigins[base+0], bounceOrigins[base+1], bounceOrigins[base+2]);
        Vec3 dir(bounceDirections[base+0], bounceDirections[base+1], bounceDirections[base+2]);
        Ray ray(origin, dir);

        HitInfo closestHit;
        MeshDeviceView hitMesh = outerShell;  // Track which mesh we hit for material resolution
        float closestT = 1e30f;

        // If additional mesh is empty, only trace shells
        if (additionalMesh.numTriangles == 0) {
            traceMesh(ray, outerShell, &closestHit, true, params.material);
        } else {
            // Two-box early culling
            Vec3 invDir(1.0f/dir.x, 1.0f/dir.y, 1.0f/dir.z);
            float tNearShells = 0.0f, tNearAdditional = 0.0f;
            bool hitShellsBox = intersectAabb(ray, invDir, shellsBounds.min, shellsBounds.max, 1e30f, &tNearShells);
            bool hitAdditionalBox = intersectAabb(ray, invDir, additionalBounds.min, additionalBounds.max, 1e30f, &tNearAdditional);

            // Trace in near-to-far order with early exit
            if (hitShellsBox && hitAdditionalBox) {
                if (tNearShells < tNearAdditional) {
                    // Check shells first
                    HitInfo shellHit;
                    if (traceMesh(ray, outerShell, &shellHit, true, params.material) && shellHit.t < closestT) {
                        closestHit = shellHit;
                        closestT = shellHit.t;
                        hitMesh = outerShell;
                    }
                    // Only check additional if it could be closer
                    if (tNearAdditional < closestT) {
                        HitInfo addHit;
                        if (traceMesh(ray, additionalMesh, &addHit, true, params.material) && addHit.t < closestT) {
                            closestHit = addHit;
                            hitMesh = additionalMesh;
                        }
                    }
                } else {
                    // Check additional first, then shells
                    HitInfo addHit;
                    if (traceMesh(ray, additionalMesh, &addHit, true, params.material) && addHit.t < closestT) {
                        closestHit = addHit;
                        closestT = addHit.t;
                        hitMesh = additionalMesh;
                    }
                    if (tNearShells < closestT) {
                        HitInfo shellHit;
                        if (traceMesh(ray, outerShell, &shellHit, true, params.material) && shellHit.t < closestT) {
                            closestHit = shellHit;
                            hitMesh = outerShell;
                        }
                    }
                }
            } else if (hitShellsBox) {
                traceMesh(ray, outerShell, &closestHit, true, params.material);
            } else if (hitAdditionalBox) {
                if (traceMesh(ray, additionalMesh, &closestHit, true, params.material)) {
                    hitMesh = additionalMesh;
                }
            }
        }

        // Populate output
        if (closestHit.valid()) {
            bouncePositions[base+0] = closestHit.position.x;
            bouncePositions[base+1] = closestHit.position.y;
            bouncePositions[base+2] = closestHit.position.z;
            bounceNormals[base+0] = closestHit.shadingNormal.x;
            bounceNormals[base+1] = closestHit.shadingNormal.y;
            bounceNormals[base+2] = closestHit.shadingNormal.z;

            // Resolve material
            const Material* mat = &params.material;
            if (closestHit.materialId >= 0 && closestHit.materialId < hitMesh.numMaterials && hitMesh.materials) {
                mat = &hitMesh.materials[closestHit.materialId];
            }
            ResolvedMaterial resolved = resolveMaterial(*mat, closestHit.uv, hitMesh);
            bounceColors[base+0] = resolved.base_color.x;
            bounceColors[base+1] = resolved.base_color.y;
            bounceColors[base+2] = resolved.base_color.z;
            bounceHitFlags[sampleIdx] = 1;
        } else {
            bounceHitFlags[sampleIdx] = 0;
        }
    }
}

// Finalize and output (shared kernel)
__global__ void finalizePathTracingKernel(uchar4* output,
                                          Vec3* accum,
                                          const Vec3* radiance,
                                          RenderParams params) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) {
        return;
    }

    int pixelIdx = y * params.width + x;
    Vec3 sum(0.0f, 0.0f, 0.0f);

    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        sum += radiance[sampleIdx];
    }

    Vec3 prev = accum[pixelIdx];
    Vec3 newSum = prev + sum;
    accum[pixelIdx] = newSum;
    float invSamples = 1.0f / static_cast<float>(params.sampleOffset + params.samplesPerPixel);
    Vec3 color = newSum * invSamples;

    color = encodeSrgb(color);

    output[pixelIdx] = make_uchar4(
            static_cast<unsigned char>(color.x * 255.0f),
            static_cast<unsigned char>(color.y * 255.0f),
            static_cast<unsigned char>(color.z * 255.0f),
            255);
}

// ---------------------------------------------------------------------------
// Multi-segment constants.
// ---------------------------------------------------------------------------
constexpr int kMaxSegmentIterations = 10;
constexpr float kSegmentEpsilon = 1e-8f;

// ---------------------------------------------------------------------------
// Initial outer shell entry tracing for multi-segment method.
// ---------------------------------------------------------------------------
__global__ void traceOuterShellEntryKernel(
        float* entryPositions,
        float* entryT,
        float* rayDirections,
        int* activeFlags,
        float* accumT,
        RenderParams params,
        MeshDeviceView outerShell) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) {
        return;
    }

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        int base = sampleIdx * 3;
        uint32_t rng = initRng(pixelIdx, params.sampleOffset, s);
        Ray ray = generatePrimaryRay(x, y, params, rng);

        // Store ray direction
        rayDirections[base + 0] = ray.direction.x;
        rayDirections[base + 1] = ray.direction.y;
        rayDirections[base + 2] = ray.direction.z;

        // Trace outer shell entry (FORWARD_ONLY: allow_backward=false, allow_forward=true)
        HitInfo outerHit;
        bool hitOuter = traceMeshWithMode(ray, outerShell, &outerHit, TraceMode::FORWARD_ONLY, false, params.material);

        if (hitOuter) {
            Vec3 entryPos = ray.at(outerHit.t);
            entryPositions[base + 0] = entryPos.x;
            entryPositions[base + 1] = entryPos.y;
            entryPositions[base + 2] = entryPos.z;
            entryT[sampleIdx] = outerHit.t;
            activeFlags[sampleIdx] = 1;
            accumT[sampleIdx] = outerHit.t;
        } else {
            entryPositions[base + 0] = 0.0f;
            entryPositions[base + 1] = 0.0f;
            entryPositions[base + 2] = 0.0f;
            entryT[sampleIdx] = 0.0f;
            activeFlags[sampleIdx] = 0;
            accumT[sampleIdx] = 0.0f;
        }
    }
}

// ---------------------------------------------------------------------------
// Initial outer shell entry tracing for arbitrary rays.
// Handles rays that start inside the outer shell by exiting first.
// ---------------------------------------------------------------------------
__global__ void traceOuterShellEntryFromRaysKernel(
        const float* rayOrigins,
        const float* rayDirections,
        const int* rayActiveMask,
        const float* rayPdfs,
        float* entryPositions,
        float* entryT,
        int* activeFlags,
        float* accumT,
        RenderParams params,
        MeshDeviceView outerShell) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) {
        return;
    }

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        int base = sampleIdx * 3;

        if (rayActiveMask && !rayActiveMask[sampleIdx]) {
            entryPositions[base + 0] = 0.0f;
            entryPositions[base + 1] = 0.0f;
            entryPositions[base + 2] = 0.0f;
            entryT[sampleIdx] = 0.0f;
            activeFlags[sampleIdx] = 0;
            accumT[sampleIdx] = 0.0f;
            continue;
        }
        if (rayPdfs && rayPdfs[sampleIdx] <= 0.0f) {
            entryPositions[base + 0] = 0.0f;
            entryPositions[base + 1] = 0.0f;
            entryPositions[base + 2] = 0.0f;
            entryT[sampleIdx] = 0.0f;
            activeFlags[sampleIdx] = 0;
            accumT[sampleIdx] = 0.0f;
            continue;
        }

        Vec3 origin(rayOrigins[base + 0], rayOrigins[base + 1], rayOrigins[base + 2]);
        Vec3 dir(rayDirections[base + 0], rayDirections[base + 1], rayDirections[base + 2]);
        Ray ray(origin, dir);

        HitInfo outerHit;
        bool hitOuter = traceMeshWithMode(ray, outerShell, &outerHit, TraceMode::FORWARD_ONLY, false, params.material);

        float baseOffset = 0.0f;
        Vec3 entryOrigin = origin;
        if (!hitOuter) {
            HitInfo exitHit;
            bool hitExit = traceMeshWithMode(ray, outerShell, &exitHit, TraceMode::BACKWARD_ONLY, false, params.material);
            if (hitExit) {
                baseOffset = exitHit.t + kSegmentEpsilon;
                entryOrigin = origin + dir * baseOffset;
                Ray shiftedRay(entryOrigin, dir);
                hitOuter = traceMeshWithMode(shiftedRay, outerShell, &outerHit, TraceMode::FORWARD_ONLY, false, params.material);
            }
        }

        if (hitOuter) {
            Vec3 entryPos = entryOrigin + dir * outerHit.t;
            float totalEntryT = baseOffset + outerHit.t;
            entryPositions[base + 0] = entryPos.x;
            entryPositions[base + 1] = entryPos.y;
            entryPositions[base + 2] = entryPos.z;
            entryT[sampleIdx] = totalEntryT;
            activeFlags[sampleIdx] = 1;
            accumT[sampleIdx] = totalEntryT;
        } else {
            entryPositions[base + 0] = 0.0f;
            entryPositions[base + 1] = 0.0f;
            entryPositions[base + 2] = 0.0f;
            entryT[sampleIdx] = 0.0f;
            activeFlags[sampleIdx] = 0;
            accumT[sampleIdx] = 0.0f;
        }
    }
}

// ---------------------------------------------------------------------------
// Trace segment exits: outer shell backward and inner shell forward.
// Computes exit position as min(outer_exit, inner_enter).
// ---------------------------------------------------------------------------
__global__ void traceSegmentExitsKernel(
        const float* entryPositions,
        const float* rayDirections,
        const int* hitIndices,
        int hitCount,
        MeshDeviceView outerShell,
        MeshDeviceView innerShell,
        Material material,
        float* exitPositions,
        float* outerExitT,
        float* innerEnterT,
        int* innerHitFlags) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= hitCount) {
        return;
    }

    int sampleIdx = hitIndices[idx];
    int base = sampleIdx * 3;

    Vec3 entryPos(entryPositions[base + 0],
                  entryPositions[base + 1],
                  entryPositions[base + 2]);
    Vec3 dir(rayDirections[base + 0],
             rayDirections[base + 1],
             rayDirections[base + 2]);

    // Shift entry point into shell by epsilon (matching Python: x_outer_enter + ds_left * eps)
    Vec3 shiftedEntry = entryPos + dir * kSegmentEpsilon;
    Ray ray(shiftedEntry, dir);

    // Trace outer shell EXIT (BACKWARD_ONLY: allow_backward=true, allow_forward=false)
    HitInfo outerExit;
    bool hitOuterExit = traceMeshWithMode(ray, outerShell, &outerExit, TraceMode::BACKWARD_ONLY, false, material);

    float exitT;
    if (hitOuterExit) {
        exitT = outerExit.t;
    } else {
        // Fallback: minimal segment (matching Python: x_outer_exit_t[~mask] = 1e-8)
        exitT = kSegmentEpsilon;
    }
    outerExitT[sampleIdx] = exitT;

    // Trace inner shell (ANY mode, allow_negative=True as in Python)
    HitInfo innerHit;
    bool hitInner = traceMeshWithMode(ray, innerShell, &innerHit, TraceMode::ANY, false, material);

    float innerT;
    if (hitInner) {
        innerT = innerHit.t;
        innerHitFlags[sampleIdx] = 1;
    } else {
        innerT = 1e30f;  // No inner hit
        innerHitFlags[sampleIdx] = 0;
    }
    innerEnterT[sampleIdx] = innerT;

    // Exit position is the nearer of outer_exit or inner_enter
    // (matching Python: inner_apply = x_inner_mask & (x_inner_t < x_outer_exit_t))
    // Note: Python allows negative inner_t (allow_negative=True) so we don't check > 0
    bool innerBeforeOuter = hitInner && (innerT < exitT);
    Vec3 exitPos;
    if (innerBeforeOuter) {
        exitPos = shiftedEntry + dir * innerT;
    } else {
        exitPos = shiftedEntry + dir * exitT;
    }

    exitPositions[base + 0] = exitPos.x;
    exitPositions[base + 1] = exitPos.y;
    exitPositions[base + 2] = exitPos.z;
}

// ---------------------------------------------------------------------------
// Build normalized neural network inputs for current segment.
// ---------------------------------------------------------------------------
// Writes flat input for NetworkWithInputEncoding:
//   [entry.xyz | exit.xyz | [mid.xyz] | dir.xyz]  (inputDims floats per ray)
__global__ void buildSegmentNeuralInputsKernel(
        const float* entryPositions,
        const float* exitPositions,
        const float* rayDirections,
        const int* hitIndices,
        int hitCount,
        Vec3 outerMin,
        Vec3 outerInvExtent,
        float* networkInputs,
        int pointCount,
        int inputDims) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= hitCount) {
        return;
    }

    int sampleIdx = hitIndices[idx];
    int srcBase = sampleIdx * 3;
    int dstBase = idx * inputDims;

    // Shift entry by epsilon before normalization (matching Python)
    Vec3 entryPos(entryPositions[srcBase + 0],
                  entryPositions[srcBase + 1],
                  entryPositions[srcBase + 2]);
    Vec3 dir(rayDirections[srcBase + 0],
             rayDirections[srcBase + 1],
             rayDirections[srcBase + 2]);
    Vec3 shiftedEntry = entryPos + dir * kSegmentEpsilon;

    Vec3 exitPos(exitPositions[srcBase + 0],
                 exitPositions[srcBase + 1],
                 exitPositions[srcBase + 2]);

    // Normalize positions w.r.t. outer shell bounds
    Vec3 normEntry((shiftedEntry.x - outerMin.x) * outerInvExtent.x,
                   (shiftedEntry.y - outerMin.y) * outerInvExtent.y,
                   (shiftedEntry.z - outerMin.z) * outerInvExtent.z);
    Vec3 normExit((exitPos.x - outerMin.x) * outerInvExtent.x,
                  (exitPos.y - outerMin.y) * outerInvExtent.y,
                  (exitPos.z - outerMin.z) * outerInvExtent.z);

    // Entry (dims 0–2)
    networkInputs[dstBase + 0] = normEntry.x;
    networkInputs[dstBase + 1] = normEntry.y;
    networkInputs[dstBase + 2] = normEntry.z;
    // Exit (dims 3–5)
    networkInputs[dstBase + 3] = normExit.x;
    networkInputs[dstBase + 4] = normExit.y;
    networkInputs[dstBase + 5] = normExit.z;
    // Midpoint (dims 6–8, only when pointCount == 3)
    if (pointCount == 3) {
        Vec3 midPos = (shiftedEntry + exitPos) * 0.5f;
        Vec3 normMid((midPos.x - outerMin.x) * outerInvExtent.x,
                     (midPos.y - outerMin.y) * outerInvExtent.y,
                     (midPos.z - outerMin.z) * outerInvExtent.z);
        networkInputs[dstBase + 6] = normMid.x;
        networkInputs[dstBase + 7] = normMid.y;
        networkInputs[dstBase + 8] = normMid.z;
    }
    // Direction (dims pointCount*3 to pointCount*3+2): map [-1,1] → [0,1]
    int dirOffset = pointCount * 3;
    networkInputs[dstBase + dirOffset + 0] = (dir.x + 1.0f) * 0.5f;
    networkInputs[dstBase + dirOffset + 1] = (dir.y + 1.0f) * 0.5f;
    networkInputs[dstBase + dirOffset + 2] = (dir.z + 1.0f) * 0.5f;
}

// ---------------------------------------------------------------------------
// Apply neural network outputs and update ray state.
// Handles: intersection found, inner shell forces intersection.
// ---------------------------------------------------------------------------
__global__ void applySegmentNeuralOutputKernel(
        const __half* outputs,
        int outputStride,
        const int* hitIndices,
        int hitCount,
        const float* entryPositions,
        const float* rayDirections,
        const float* accumT,
        const int* innerHitFlags,
        const float* innerEnterT,
        const float* outerExitT,
        float* hitPositions,
        float* hitNormals,
        float* hitColors,
        float* hitMaterialParams,
        int* hitFlags,
        int* activeFlags,
        float* hitDistances,
        Material material) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= hitCount) {
        return;
    }

    int sampleIdx = hitIndices[idx];
    int base = sampleIdx * 3;
    int outBase = idx * outputStride;

    float hasIntersection = __half2float(outputs[outBase + 0]);
    float distance = __half2float(outputs[outBase + 1]);
    float nx = __half2float(outputs[outBase + 2]);
    float ny = __half2float(outputs[outBase + 3]);
    float nz = __half2float(outputs[outBase + 4]);
    float cr = __half2float(outputs[outBase + 5]);
    float cg = __half2float(outputs[outBase + 6]);
    float cb = __half2float(outputs[outBase + 7]);

    Vec3 entryPos(entryPositions[base + 0],
                  entryPositions[base + 1],
                  entryPositions[base + 2]);
    Vec3 dir(rayDirections[base + 0],
             rayDirections[base + 1],
             rayDirections[base + 2]);

    // Check if neural network predicts intersection
    // (matching Python: pred_intersection_mask = (pred_intersection >= 0))
    bool neuralHit = (hasIntersection >= 0.0f);

    // Check if inner shell hit before outer exit - forces intersection
    // (matching Python: pred_intersection_mask[x_inner_mask & (x_inner_t < x_outer_exit_t)] = True)
    // Note: Python allows negative inner_t (allow_negative=True) so we don't check > 0
    bool innerHitBeforeExit = (innerHitFlags[sampleIdx] != 0) &&
                               (innerEnterT[sampleIdx] < outerExitT[sampleIdx]);

    bool foundIntersection = neuralHit || innerHitBeforeExit;

    if (foundIntersection) {
        // Compute final hit position
        // The entry position is at accumT from camera, plus predicted distance from entry
        // (matching Python: pred_t_global = pred_t + accum_t)
        // But note: the neural network predicts distance from shifted entry point
        Vec3 shiftedEntry = entryPos + dir * kSegmentEpsilon;
        Vec3 hitPos = shiftedEntry + dir * distance * 0;

        hitPositions[base + 0] = hitPos.x;
        hitPositions[base + 1] = hitPos.y;
        hitPositions[base + 2] = hitPos.z;

        // Normalize and store normal
        Vec3 normal(nx, ny, nz);
        float nlen = length(normal);
        if (nlen > 1e-6f) {
            normal = normal / nlen;
        } else {
            normal = Vec3(0.0f, 1.0f, 0.0f);
        }
        hitNormals[base + 0] = normal.x;
        hitNormals[base + 1] = normal.y;
        hitNormals[base + 2] = normal.z;

        Vec3 fallbackColor(material.base_color.value.x,
                           material.base_color.value.y,
                           material.base_color.value.z);
        Vec3 neuralColor = fallbackColor;
        if (outputStride >= 8) {
            neuralColor.x = saturate(cr);
            neuralColor.y = saturate(cg);
            neuralColor.z = saturate(cb);
        }
        hitColors[base + 0] = neuralColor.x;
        hitColors[base + 1] = neuralColor.y;
        hitColors[base + 2] = neuralColor.z;
        // hitColors[base + 0] = 0.8;
        // hitColors[base + 1] = 0.8;
        // hitColors[base + 2] = 0.8;
        if (hitMaterialParams) {
            // hitMaterialParams[base + 0] = material.metallic.value;
            // hitMaterialParams[base + 1] = material.roughness.value;
            // hitMaterialParams[base + 2] = material.specular.value;
            hitMaterialParams[base + 0] = 0.0;
            hitMaterialParams[base + 1] = 0.0;
            hitMaterialParams[base + 2] = 0.0;
        }

        hitFlags[sampleIdx] = 1;
        activeFlags[sampleIdx] = 0;  // Ray done

        // Store neural predicted distance for potential use in bounce rays
        if (hitDistances) {
            hitDistances[sampleIdx] = distance;
        }
    }
    // If no intersection found, activeFlags remains 1 (will be updated by prepareNextIterationKernel)
}

// ---------------------------------------------------------------------------
// Trace additional mesh for all primary rays (hybrid rendering)
// ---------------------------------------------------------------------------
__global__ void traceAdditionalMeshPrimaryRaysKernel(
        float* hitPositions,
        float* hitNormals,
        float* hitColors,
        float* hitMaterialParams,
        int* hitFlags,
        RenderParams params,
        MeshDeviceView additionalMesh) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) return;

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        int base = sampleIdx * 3;
        if (additionalMesh.numTriangles == 0) {
            hitFlags[sampleIdx] = 0;
            continue;
        }

        // Reconstruct primary ray (same as shell tracing)
        uint32_t rng = initRng(pixelIdx, params.sampleOffset, s);
        Ray ray = generatePrimaryRay(x, y, params, rng);

        // Trace against additional mesh
        HitInfo hit;
        if (traceMesh(ray, additionalMesh, &hit, true, params.material)) {
            int base = sampleIdx * 3;
            hitPositions[base+0] = hit.position.x;
            hitPositions[base+1] = hit.position.y;
            hitPositions[base+2] = hit.position.z;
            hitNormals[base+0] = hit.shadingNormal.x;
            hitNormals[base+1] = hit.shadingNormal.y;
            hitNormals[base+2] = hit.shadingNormal.z;

            // Resolve material
            const Material* mat = &params.material;
            if (hit.materialId >= 0 && hit.materialId < additionalMesh.numMaterials && additionalMesh.materials) {
                mat = &additionalMesh.materials[hit.materialId];
            }
            ResolvedMaterial resolved = resolveMaterial(*mat, hit.uv, additionalMesh);
            hitColors[base+0] = resolved.base_color.x;
            hitColors[base+1] = resolved.base_color.y;
            hitColors[base+2] = resolved.base_color.z;
            hitFlags[sampleIdx] = 1;
            if (hitMaterialParams) {
                hitMaterialParams[base+0] = resolved.metallic;
                hitMaterialParams[base+1] = resolved.roughness;
                hitMaterialParams[base+2] = resolved.specular;
            }
        } else {
            hitFlags[sampleIdx] = 0;
            if (hitMaterialParams) {
                hitMaterialParams[base+0] = params.material.metallic.value;
                hitMaterialParams[base+1] = params.material.roughness.value;
                hitMaterialParams[base+2] = params.material.specular.value;
            }
        }
    }
}

// ---------------------------------------------------------------------------
// Resolve colors for hits written by OptiX raygen programs.
// OptiX packs [uv.x, uv.y, reinterpret<float>(materialId)] into hitColors.
// This regular CUDA kernel reads those and writes the actual resolved color.
// ---------------------------------------------------------------------------
__global__ void resolveHitColorsKernel(
        float* hitColors,
        float* hitMaterialParams,
        const int* hitFlags,
        RenderParams params,
        MeshDeviceView mesh) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) return;

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        int base = sampleIdx * 3;
        if (!hitFlags[sampleIdx]) continue;

        float uvx = hitColors[base + 0];
        float uvy = hitColors[base + 1];
        int materialId = __float_as_int(hitColors[base + 2]);
        Vec2 uv(uvx, uvy);

        const Material* mat = &params.material;
        if (materialId >= 0 && materialId < mesh.numMaterials && mesh.materials) {
            mat = &mesh.materials[materialId];
        }
        ResolvedMaterial resolved = resolveMaterial(*mat, uv, mesh);
        hitColors[base + 0] = resolved.base_color.x;
        hitColors[base + 1] = resolved.base_color.y;
        hitColors[base + 2] = resolved.base_color.z;
        if (hitMaterialParams) {
            hitMaterialParams[base + 0] = resolved.metallic;
            hitMaterialParams[base + 1] = resolved.roughness;
            hitMaterialParams[base + 2] = resolved.specular;
        }
    }
}

// ---------------------------------------------------------------------------
// Trace additional mesh for arbitrary rays (hybrid rendering).
// ---------------------------------------------------------------------------
__global__ void traceAdditionalMeshRaysKernel(
        const float* rayOrigins,
        const float* rayDirections,
        const float* rayPdfs,
        float* hitPositions,
        float* hitNormals,
        float* hitColors,
        float* hitMaterialParams,
        int* hitFlags,
        RenderParams params,
        MeshDeviceView additionalMesh) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) return;

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        int base = sampleIdx * 3;

        if (additionalMesh.numTriangles == 0) {
            hitFlags[sampleIdx] = 0;
            continue;
        }

        if (rayPdfs && rayPdfs[sampleIdx] <= 0.0f) {
            hitFlags[sampleIdx] = 0;
            continue;
        }

        Vec3 origin(rayOrigins[base + 0], rayOrigins[base + 1], rayOrigins[base + 2]);
        Vec3 dir(rayDirections[base + 0], rayDirections[base + 1], rayDirections[base + 2]);
        Ray ray(origin, dir);

        HitInfo hit;
        if (traceMesh(ray, additionalMesh, &hit, false, params.material)) {
            hitPositions[base + 0] = hit.position.x;
            hitPositions[base + 1] = hit.position.y;
            hitPositions[base + 2] = hit.position.z;
            hitNormals[base + 0] = hit.shadingNormal.x;
            hitNormals[base + 1] = hit.shadingNormal.y;
            hitNormals[base + 2] = hit.shadingNormal.z;

            // Resolve material
            const Material* mat = &params.material;
            if (hit.materialId >= 0 && hit.materialId < additionalMesh.numMaterials && additionalMesh.materials) {
                mat = &additionalMesh.materials[hit.materialId];
            }
            ResolvedMaterial resolved = resolveMaterial(*mat, hit.uv, additionalMesh);
            hitColors[base + 0] = resolved.base_color.x;
            hitColors[base + 1] = resolved.base_color.y;
            hitColors[base + 2] = resolved.base_color.z;
            hitFlags[sampleIdx] = 1;
            if (hitMaterialParams) {
                hitMaterialParams[base + 0] = resolved.metallic;
                hitMaterialParams[base + 1] = resolved.roughness;
                hitMaterialParams[base + 2] = resolved.specular;
            }
        } else {
            hitFlags[sampleIdx] = 0;
            if (hitMaterialParams) {
                hitMaterialParams[base + 0] = params.material.metallic.value;
                hitMaterialParams[base + 1] = params.material.roughness.value;
                hitMaterialParams[base + 2] = params.material.specular.value;
            }
        }
    }
}

// ---------------------------------------------------------------------------
// Select closest hit between shells and additional mesh (hybrid rendering)
// ---------------------------------------------------------------------------
__global__ void selectClosestPrimaryHitKernel(
        float* shellHitPositions,
        float* shellHitNormals,
        float* shellHitColors,
        float* shellHitMaterialParams,
        int* shellHitFlags,
        const float* additionalHitPositions,
        const float* additionalHitNormals,
        const float* additionalHitColors,
        const float* additionalHitMaterialParams,
        const int* additionalHitFlags,
        RenderParams params) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) return;

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        int base = sampleIdx * 3;

        bool shellHit = shellHitFlags[sampleIdx] != 0;
        bool additionalHit = additionalHitFlags[sampleIdx] != 0;

        if (shellHit && additionalHit) {
            // Both hit - compute distances and use closer
            Vec3 rayOrigin = params.camPos;
            Vec3 shellPos(shellHitPositions[base+0], shellHitPositions[base+1], shellHitPositions[base+2]);
            Vec3 additionalPos(additionalHitPositions[base+0], additionalHitPositions[base+1], additionalHitPositions[base+2]);

            float shellDist = length(shellPos - rayOrigin);
            float additionalDist = length(additionalPos - rayOrigin);

            if (additionalDist < shellDist) {
                // Use additional mesh hit
                shellHitPositions[base+0] = additionalHitPositions[base+0];
                shellHitPositions[base+1] = additionalHitPositions[base+1];
                shellHitPositions[base+2] = additionalHitPositions[base+2];
                shellHitNormals[base+0] = additionalHitNormals[base+0];
                shellHitNormals[base+1] = additionalHitNormals[base+1];
                shellHitNormals[base+2] = additionalHitNormals[base+2];
                shellHitColors[base+0] = additionalHitColors[base+0];
                shellHitColors[base+1] = additionalHitColors[base+1];
                shellHitColors[base+2] = additionalHitColors[base+2];
                if (shellHitMaterialParams && additionalHitMaterialParams) {
                    shellHitMaterialParams[base+0] = additionalHitMaterialParams[base+0];
                    shellHitMaterialParams[base+1] = additionalHitMaterialParams[base+1];
                    shellHitMaterialParams[base+2] = additionalHitMaterialParams[base+2];
                }
            }
            // Else keep shell hit
        } else if (additionalHit) {
            // Only additional mesh hit
            shellHitPositions[base+0] = additionalHitPositions[base+0];
            shellHitPositions[base+1] = additionalHitPositions[base+1];
            shellHitPositions[base+2] = additionalHitPositions[base+2];
            shellHitNormals[base+0] = additionalHitNormals[base+0];
            shellHitNormals[base+1] = additionalHitNormals[base+1];
            shellHitNormals[base+2] = additionalHitNormals[base+2];
            shellHitColors[base+0] = additionalHitColors[base+0];
            shellHitColors[base+1] = additionalHitColors[base+1];
            shellHitColors[base+2] = additionalHitColors[base+2];
            if (shellHitMaterialParams && additionalHitMaterialParams) {
                shellHitMaterialParams[base+0] = additionalHitMaterialParams[base+0];
                shellHitMaterialParams[base+1] = additionalHitMaterialParams[base+1];
                shellHitMaterialParams[base+2] = additionalHitMaterialParams[base+2];
            }
            shellHitFlags[sampleIdx] = 1;
        }
        // Else keep shell hit or miss
    }
}

// ---------------------------------------------------------------------------
// Select closest hit between shells and additional mesh (per-ray origin).
// ---------------------------------------------------------------------------
__global__ void selectClosestHitKernel(
        float* shellHitPositions,
        float* shellHitNormals,
        float* shellHitColors,
        float* shellHitMaterialParams,
        int* shellHitFlags,
        const float* additionalHitPositions,
        const float* additionalHitNormals,
        const float* additionalHitColors,
        const float* additionalHitMaterialParams,
        const int* additionalHitFlags,
        const float* rayOrigins,
        RenderParams params) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) return;

    int pixelIdx = y * params.width + x;
    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        int base = sampleIdx * 3;

        bool shellHit = shellHitFlags[sampleIdx] != 0;
        bool additionalHit = additionalHitFlags[sampleIdx] != 0;

        if (shellHit && additionalHit) {
            Vec3 rayOrigin(rayOrigins[base + 0], rayOrigins[base + 1], rayOrigins[base + 2]);
            Vec3 shellPos(shellHitPositions[base + 0], shellHitPositions[base + 1], shellHitPositions[base + 2]);
            Vec3 additionalPos(additionalHitPositions[base + 0], additionalHitPositions[base + 1], additionalHitPositions[base + 2]);

            float shellDist = length(shellPos - rayOrigin);
            float additionalDist = length(additionalPos - rayOrigin);

            if (additionalDist < shellDist) {
                shellHitPositions[base + 0] = additionalHitPositions[base + 0];
                shellHitPositions[base + 1] = additionalHitPositions[base + 1];
                shellHitPositions[base + 2] = additionalHitPositions[base + 2];
                shellHitNormals[base + 0] = additionalHitNormals[base + 0];
                shellHitNormals[base + 1] = additionalHitNormals[base + 1];
                shellHitNormals[base + 2] = additionalHitNormals[base + 2];
                shellHitColors[base + 0] = additionalHitColors[base + 0];
                shellHitColors[base + 1] = additionalHitColors[base + 1];
                shellHitColors[base + 2] = additionalHitColors[base + 2];
                if (shellHitMaterialParams && additionalHitMaterialParams) {
                    shellHitMaterialParams[base + 0] = additionalHitMaterialParams[base + 0];
                    shellHitMaterialParams[base + 1] = additionalHitMaterialParams[base + 1];
                    shellHitMaterialParams[base + 2] = additionalHitMaterialParams[base + 2];
                }
            }
        } else if (additionalHit) {
            shellHitPositions[base + 0] = additionalHitPositions[base + 0];
            shellHitPositions[base + 1] = additionalHitPositions[base + 1];
            shellHitPositions[base + 2] = additionalHitPositions[base + 2];
            shellHitNormals[base + 0] = additionalHitNormals[base + 0];
            shellHitNormals[base + 1] = additionalHitNormals[base + 1];
            shellHitNormals[base + 2] = additionalHitNormals[base + 2];
            shellHitColors[base + 0] = additionalHitColors[base + 0];
            shellHitColors[base + 1] = additionalHitColors[base + 1];
            shellHitColors[base + 2] = additionalHitColors[base + 2];
            if (shellHitMaterialParams && additionalHitMaterialParams) {
                shellHitMaterialParams[base + 0] = additionalHitMaterialParams[base + 0];
                shellHitMaterialParams[base + 1] = additionalHitMaterialParams[base + 1];
                shellHitMaterialParams[base + 2] = additionalHitMaterialParams[base + 2];
            }
            shellHitFlags[sampleIdx] = 1;
        }
    }
}

// ---------------------------------------------------------------------------
// Prepare for next iteration: trace outer shell re-entry and update state.
// Implements: mask_for_remaining_rays = ~pred_intersection_mask & (x_outer_enter_mask_new | x_inner_mask)
// ---------------------------------------------------------------------------
__global__ void prepareNextIterationKernel(
        const float* exitPositions,
        const float* outerExitT,
        const float* rayDirections,
        const int* innerHitFlags,
        const int* hitIndices,
        int hitCount,
        MeshDeviceView outerShell,
        Material material,
        float* entryPositions,
        int* activeFlags,
        float* accumT,
        float* newEntryT) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= hitCount) {
        return;
    }

    int sampleIdx = hitIndices[idx];

    // Skip if ray already found intersection (activeFlags was set to 0)
    if (activeFlags[sampleIdx] == 0) {
        return;
    }

    int base = sampleIdx * 3;
    Vec3 exitPos(exitPositions[base + 0],
                 exitPositions[base + 1],
                 exitPositions[base + 2]);
    Vec3 dir(rayDirections[base + 0],
             rayDirections[base + 1],
             rayDirections[base + 2]);

    // Shift exit point outward by epsilon (matching Python: x_outer_exit + ds_left * eps)
    Vec3 shiftedExit = exitPos + dir * kSegmentEpsilon;
    Ray ray(shiftedExit, dir);

    // Trace outer shell for re-entry (FORWARD_ONLY)
    HitInfo reentry;
    bool hitReentry = traceMeshWithMode(ray, outerShell, &reentry, TraceMode::FORWARD_ONLY, false, material);

    // Remaining rays condition (matching Python):
    // mask_for_remaining_rays = ~pred_intersection_mask & (x_outer_enter_mask_new | x_inner_mask)
    // At this point, activeFlags[sampleIdx] == 1 means no intersection was found
    // So we check: can re-enter outer shell OR hit inner shell
    bool canContinue = hitReentry || (innerHitFlags[sampleIdx] != 0);

    if (canContinue) {
        // Get re-entry distance (0 if no re-entry found, matching Python behavior
        // where x_outer_enter_t_new may be 0 or invalid for non-hits)
        float reentryDist = hitReentry ? reentry.t : 0.0f;

        // Update entry position for next iteration
        // (matching Python: x_outer_enter_new = x_outer_exit + ds_left * x_outer_enter_t_new)
        Vec3 newEntry = shiftedExit + dir * reentryDist;
        entryPositions[base + 0] = newEntry.x;
        entryPositions[base + 1] = newEntry.y;
        entryPositions[base + 2] = newEntry.z;

        // Update accumulated distance
        // (matching Python: accum_t = accum_t + x_outer_exit_t + x_outer_enter_t_new)
        accumT[sampleIdx] = accumT[sampleIdx] + outerExitT[sampleIdx] + reentryDist + 2.0f * kSegmentEpsilon;
        newEntryT[sampleIdx] = reentryDist;
        activeFlags[sampleIdx] = 1;
    } else {
        // Ray escapes - no more segments (no re-entry AND no inner shell hit)
        activeFlags[sampleIdx] = 0;
    }
}

// ---------------------------------------------------------------------------
// Compact outer shell hits.
// ---------------------------------------------------------------------------
__global__ void compactInputsKernel(const int* flags,
                                    int count,
                                    int* hitIndices,
                                    int* hitCount) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= count) {
        return;
    }
    if (flags[idx]) {
        int slot = atomicAdd(hitCount, 1);
        hitIndices[slot] = idx;
    }
}


// ---------------------------------------------------------------------------
// Lambert shading (no bounces).
// ---------------------------------------------------------------------------
__global__ void lambertKernel(uchar4* output,
                              const float* hitNormals,
                              const float* hitColors,
                              const int* hitFlags,
                              RenderParams params,
                              EnvironmentDeviceView env) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= params.width || y >= params.height) {
        return;
    }

    int pixelIdx = y * params.width + x;
    Vec3 sum(0.0f, 0.0f, 0.0f);
    if (params.samplesPerPixel <= 0 || params.pixelCount <= 0) {
        return;
    }

    for (int s = 0; s < params.samplesPerPixel; ++s) {
        int sampleIdx = pixelIdx + s * params.pixelCount;
        uint32_t rng = initRng(pixelIdx, params.sampleOffset, s);
        Ray primaryRay = generatePrimaryRay(x, y, params, rng);

        Vec3 color(0.0f, 0.0f, 0.0f);
        if (hitFlags[sampleIdx]) {
            Vec3 normal(
                    hitNormals[sampleIdx * 3 + 0],
                    hitNormals[sampleIdx * 3 + 1],
                    hitNormals[sampleIdx * 3 + 2]);
            Vec3 baseColor(
                    hitColors[sampleIdx * 3 + 0],
                    hitColors[sampleIdx * 3 + 1],
                    hitColors[sampleIdx * 3 + 2]);
            float nlen = length(normal);
            if (nlen > 0.0f) {
                normal = normal / nlen;
            } else {
                normal = Vec3(0.0f, 1.0f, 0.0f);
            }
            if (dot(normal, primaryRay.direction) > 0.0f) {
                color = Vec3(0.0f, 0.0f, 0.0f);
            } else {
                float ndotl = fmaxf(0.0f, dot(normal, -primaryRay.direction));
                color = baseColor * ndotl;
            }
        } else {
            color = sampleEnvironment(env, primaryRay.direction);
        }

        sum += color;
    }

    Vec3 color = sum * (1.0f / static_cast<float>(params.samplesPerPixel));
    color = encodeSrgb(color);

    output[pixelIdx] = make_uchar4(
            static_cast<unsigned char>(color.x * 255.0f),
            static_cast<unsigned char>(color.y * 255.0f),
            static_cast<unsigned char>(color.z * 255.0f),
            255);
}

// ---------------------------------------------------------------------------
// Utility functions.
// ---------------------------------------------------------------------------
size_t roundUp(size_t value, size_t granularity) {
    if (granularity == 0) {
        return value;
    }
    return ((value + granularity - 1) / granularity) * granularity;
}

void checkCuda(cudaError_t result, const char* context) {
    if (result != cudaSuccess) {
        std::fprintf(stderr, "CUDA error (%s): %s\n", context, cudaGetErrorString(result));
        std::exit(1);
    }
}

size_t randomSeed() {
    std::random_device device;
    size_t seed = static_cast<size_t>(device());
    if (seed == 0) {
        seed = 1;
    }
    return seed;
}

}  // namespace

// ===========================================================================
// RendererNeural implementation.
// ===========================================================================

RendererNeural::RendererNeural(Scene& scene, const NeuralNetworkConfig* nnConfig)
        : scene_(&scene),
          lightDir_(normalize(Vec3(1.0f, 1.5f, -1.0f))),
          useMidpointEncoding_(nnConfig ? nnConfig->use_midpoint_encoding : false) {
    int log2HashmapSize = 14;
    if (nnConfig != nullptr) {
        log2HashmapSize = nnConfig->log2_hashmap_size;
    }

    pointCount_ = useMidpointEncoding_ ? 3u : 2u;
    // Raw input: [entry.xyz | exit.xyz | [mid.xyz] | dir.xyz]
    inputDims_ = pointCount_ * 3u + 3u;

    // Each of the three spatial encoders handles one 3D point.
    tcnn::json hashgridConfig = {
        {"otype", "HashGrid"},
        {"n_dims_to_encode", 3},
        {"n_levels", 8},
        {"n_features_per_level", 4},
        {"log2_hashmap_size", log2HashmapSize},
        {"base_resolution", 16},
        {"per_level_scale", 2.0f},
        {"fixed_point_pos", false},
    };

    // SphericalHarmonics has no learnable parameters.
    tcnn::json dirEncConfig = {
        {"otype", "SphericalHarmonics"},
        {"n_dims_to_encode", 3},
        {"degree", 4},
    };

    // Composite: consume dims sequentially — entry | exit | [mid] | dir.
    tcnn::json nestedEncodings = tcnn::json::array();
    nestedEncodings.push_back(hashgridConfig);   // dims 0–2: entry
    nestedEncodings.push_back(hashgridConfig);   // dims 3–5: exit
    if (useMidpointEncoding_) {
        nestedEncodings.push_back(hashgridConfig);  // dims 6–8: midpoint
    }
    nestedEncodings.push_back(dirEncConfig);     // dims (pointCount*3) – (pointCount*3+2): direction

    tcnn::json encodingConfig = {
        {"otype", "Composite"},
        {"nested", nestedEncodings},
    };

    tcnn::json mlpConfig = {
        {"otype", "FullyFusedMLP"},
        {"activation", "LeakyReLU"},
        {"output_activation", "None"},
        {"n_neurons", 128},
        {"n_hidden_layers", 4},
    };

    network_ = std::make_shared<tcnn::NetworkWithInputEncoding<__half>>(
        inputDims_, 5u, encodingConfig, mlpConfig);

    mlpOutputDims_ = network_->padded_output_width();
    mlpOutputElemSize_ = sizeof(__half);

    // Allocate a single contiguous FP16 parameter block.
    // NetworkWithInputEncoding::set_params_impl layout: [network (MLP) | encoding (composite)].
    size_t nParams = network_->n_params();
    networkParamsBytes_ = nParams * sizeof(__half);
    checkCuda(cudaMalloc(&networkParams_, networkParamsBytes_), "cudaMalloc networkParams");

    // Zero-initialise; weights are loaded from file before use.
    checkCuda(cudaMemset(networkParams_, 0, networkParamsBytes_), "cudaMemset networkParams");

    network_->set_params(static_cast<__half*>(networkParams_),
                         static_cast<__half*>(networkParams_),
                         nullptr);

    std::printf("Neural architecture: input_dims=%u, mlp_output=%u (requested 5), params=%zu bytes\n",
                inputDims_, mlpOutputDims_, networkParamsBytes_);

#ifdef USE_OPTIX
    optixState_ = optixCreateState(kOptixProgramsPtx);
    std::printf("OptiX state initialised (hardware RT available).\n");
#endif
}

RendererNeural::~RendererNeural() {
    release();
    releaseNetwork();
#ifdef USE_OPTIX
    optixDestroyState(optixState_);
    optixState_ = nullptr;
#endif
}

void RendererNeural::resize(int width, int height) {
    if (width == width_ && height == height_) {
        return;
    }
    release();
    width_ = width;
    height_ = height;
    if (width_ > 0 && height_ > 0) {
        checkCuda(cudaMalloc(&devicePixels_, width_ * height_ * sizeof(uchar4)), "cudaMalloc");
    }
}

void RendererNeural::setCameraBasis(const RenderBasis& basis) {
    basis_ = basis;
}

bool RendererNeural::loadWeightsFromFile(const std::string& path) {
    if (!network_ || networkParamsBytes_ == 0) {
        std::fprintf(stderr, "Neural network not initialized; cannot load weights.\n");
        return false;
    }

    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        std::fprintf(stderr, "Failed to open weights file: %s\n", path.c_str());
        return false;
    }

    // File format: [mlp_params | hg_params] (FP16), single shared HashGrid tiled to all slots.
    // If swapParamOrder_ is set, the file has [hg_params | mlp_params] (encoding first).
    size_t encNParams = network_->encoding()->n_params();  // pointCount_ HashGrids total
    size_t mlpNParams = network_->n_params() - encNParams;
    size_t hgNParams  = encNParams / pointCount_;
    size_t fileBytes  = (mlpNParams + hgNParams) * sizeof(__half);

    std::streamsize size = file.tellg();
    if (size <= 0) {
        std::fprintf(stderr, "Weights file is empty: %s\n", path.c_str());
        return false;
    }
    if (static_cast<size_t>(size) != fileBytes) {
        std::fprintf(stderr,
                     "Weights size mismatch (got %lld bytes, expected %zu).\n"
                     "Format: [mlp | hg] or (with swapParamOrder) [hg | mlp] (FP16).\n",
                     static_cast<long long>(size), fileBytes);
        return false;
    }

    std::vector<char> buffer(fileBytes);
    file.seekg(0, std::ios::beg);
    if (!file.read(buffer.data(), static_cast<std::streamsize>(fileBytes))) {
        std::fprintf(stderr, "Failed to read weights file: %s\n", path.c_str());
        return false;
    }

    // Copy into networkParams_ as [mlp | hg0 | hg1 | ...], tiling the single HG block.
    auto* dst        = static_cast<__half*>(networkParams_);
    const auto* src  = reinterpret_cast<const __half*>(buffer.data());
    const __half* srcMlp = swapParamOrder_ ? src + hgNParams : src;
    const __half* srcHg  = swapParamOrder_ ? src             : src + mlpNParams;
    checkCuda(cudaMemcpy(dst, srcMlp, mlpNParams * sizeof(__half), cudaMemcpyHostToDevice),
              "cudaMemcpy mlp params");
    for (uint32_t i = 0; i < pointCount_; ++i) {
        checkCuda(cudaMemcpy(dst + mlpNParams + i * hgNParams,
                             srcHg,
                             hgNParams * sizeof(__half),
                             cudaMemcpyHostToDevice),
                  "cudaMemcpy hg params tile");
    }

    network_->set_params(dst, dst, nullptr);
    return true;
}

void RendererNeural::traceNeuralSegmentsForRays(bool useCameraRays,
                                                const float* rayOrigins,
                                                const float* rayDirections,
                                                const int* rayActiveMask,
                                                const float* rayPdfs,
                                                size_t elementCount,
                                                const RenderParams& params,
                                                const MeshDeviceView& outerView,
                                                const MeshDeviceView& innerView,
                                                Vec3 outerMin,
                                                Vec3 outerInvExtent,
                                                float* outHitPositions,
                                                float* outHitNormals,
                                                float* outHitColors,
                                                float* outHitMaterialParams,
                                                int* outHitFlags,
                                                float* outHitDistances) {
    if (elementCount == 0) {
        return;
    }

    dim3 block(8, 8);
    dim3 grid((width_ + block.x - 1) / block.x, (height_ + block.y - 1) / block.y);

    int elementCountInt = static_cast<int>(elementCount);
    const int compactBlock = 256;
    int compactGrid = static_cast<int>((elementCount + compactBlock - 1) / compactBlock);

    checkCuda(cudaMemset(outHitFlags, 0, elementCount * sizeof(int)), "cudaMemset hitFlags");
    checkCuda(cudaMemset(outHitPositions, 0, elementCount * 3 * sizeof(float)), "cudaMemset hitPositions");
    checkCuda(cudaMemset(outHitNormals, 0, elementCount * 3 * sizeof(float)), "cudaMemset hitNormals");
    checkCuda(cudaMemset(outHitColors, 0, elementCount * 3 * sizeof(float)), "cudaMemset hitColors");
    if (outHitMaterialParams) {
        checkCuda(cudaMemset(outHitMaterialParams, 0, elementCount * 3 * sizeof(float)), "cudaMemset hitMaterialParams");
    }
    if (outHitDistances) {
        checkCuda(cudaMemset(outHitDistances, 0, elementCount * sizeof(float)), "cudaMemset hitDistances");
    }

    const float* segmentRayDirections = nullptr;
    if (useCameraRays) {
#ifdef USE_OPTIX
        if (useHardwareRT_ && optixState_ && optixState_->gasOuter.handle) {
            OptixLaunchParams lp = {};
            lp.gas                  = optixState_->gasOuter.handle;
            lp.renderParams         = params;
            lp.mesh                 = outerView;
            lp.entryPositions       = currentEntryPos_;
            lp.entryT               = outerExitT_;
            lp.storedRayDirections  = rayDirections_;
            lp.activeFlags          = rayActiveFlags_;
            lp.accumT               = accumT_;
            cuMemcpyHtoD(optixState_->dLaunchParams, &lp, sizeof(lp));
            optixState_->sbt.raygenRecord = optixState_->dRaygenRecordsBase +
                static_cast<unsigned int>(RaygenIndex::ShellEntry) * sizeof(RaygenRecord);
            optixLaunch(optixState_->pipeline, nullptr,
                        optixState_->dLaunchParams, sizeof(OptixLaunchParams),
                        &optixState_->sbt,
                        static_cast<unsigned int>(params.width),
                        static_cast<unsigned int>(params.height), 1);
            checkCuda(cudaDeviceSynchronize(), "optixLaunch shellEntry");
        } else
#endif
        {
        traceOuterShellEntryKernel<<<grid, block>>>(
                currentEntryPos_,
                outerExitT_,
                rayDirections_,
                rayActiveFlags_,
                accumT_,
                params,
                outerView);
        checkCuda(cudaGetLastError(), "traceOuterShellEntryKernel launch");
        }
        segmentRayDirections = rayDirections_;
    } else {
        if (!rayOrigins || !rayDirections) {
            return;
        }
#ifdef USE_OPTIX
        if (useHardwareRT_ && optixState_ && optixState_->gasOuter.handle) {
            OptixLaunchParams lp = {};
            lp.gas                = optixState_->gasOuter.handle;
            lp.renderParams       = params;
            lp.mesh               = outerView;
            lp.rayOrigins         = rayOrigins;
            lp.rayDirections      = rayDirections;
            lp.rayActiveMask      = rayActiveMask;
            lp.rayPdfs            = rayPdfs;
            lp.entryPositions     = currentEntryPos_;
            lp.entryT             = outerExitT_;
            lp.activeFlags        = rayActiveFlags_;
            lp.accumT             = accumT_;
            cuMemcpyHtoD(optixState_->dLaunchParams, &lp, sizeof(lp));
            optixState_->sbt.raygenRecord = optixState_->dRaygenRecordsBase +
                static_cast<unsigned int>(RaygenIndex::ShellEntryFromRays) * sizeof(RaygenRecord);
            optixLaunch(optixState_->pipeline, nullptr,
                        optixState_->dLaunchParams, sizeof(OptixLaunchParams),
                        &optixState_->sbt,
                        static_cast<unsigned int>(params.width),
                        static_cast<unsigned int>(params.height), 1);
            checkCuda(cudaDeviceSynchronize(), "optixLaunch shellEntryFromRays");
        } else
#endif
        {
        traceOuterShellEntryFromRaysKernel<<<grid, block>>>(
                rayOrigins,
                rayDirections,
                rayActiveMask,
                rayPdfs,
                currentEntryPos_,
                outerExitT_,
                rayActiveFlags_,
                accumT_,
                params,
                outerView);
        checkCuda(cudaGetLastError(), "traceOuterShellEntryFromRaysKernel launch");
        }
        segmentRayDirections = rayDirections;
    }

    checkCuda(cudaMemset(hitCount_, 0, sizeof(int)), "cudaMemset hitCount");
    compactInputsKernel<<<compactGrid, compactBlock>>>(
            rayActiveFlags_,
            elementCountInt,
            hitIndices_,
            hitCount_);
    checkCuda(cudaGetLastError(), "compactInputsKernel launch");

    int activeCount = 0;
    checkCuda(cudaMemcpy(&activeCount, hitCount_, sizeof(int), cudaMemcpyDeviceToHost),
              "cudaMemcpy activeCount");

    for (int iter = 0; iter < kMaxSegmentIterations && activeCount > 0; ++iter) {
        size_t activeCountSize = static_cast<size_t>(activeCount);
        size_t granularity = static_cast<size_t>(tcnn::batch_size_granularity);
        size_t paddedActiveCount = roundUp(activeCountSize, granularity);

        const int buildBlock = 256;
        int buildGrid = (activeCount + buildBlock - 1) / buildBlock;

#ifdef USE_OPTIX
        if (useHardwareRT_ && optixState_ &&
            optixState_->gasOuter.handle && optixState_->gasInner.handle) {
            OptixLaunchParams lp = {};
            lp.gas                = optixState_->gasOuter.handle;
            lp.gas2               = optixState_->gasInner.handle;
            lp.renderParams       = params;
            lp.mesh               = outerView;
            lp.mesh2              = innerView;
            lp.entryPositions     = currentEntryPos_;
            lp.storedRayDirections = const_cast<float*>(segmentRayDirections);
            lp.hitIndices         = hitIndices_;
            lp.hitCount           = activeCount;
            lp.outerExitT         = outerExitT_;
            lp.innerEnterT        = innerEnterT_;
            lp.innerHitFlags      = innerHitFlags_;
            lp.hitPositions       = segmentExitPos_;  // reused as exit positions
            cuMemcpyHtoD(optixState_->dLaunchParams, &lp, sizeof(lp));
            optixState_->sbt.raygenRecord = optixState_->dRaygenRecordsBase +
                static_cast<unsigned int>(RaygenIndex::ShellExit) * sizeof(RaygenRecord);
            optixLaunch(optixState_->pipeline, nullptr,
                        optixState_->dLaunchParams, sizeof(OptixLaunchParams),
                        &optixState_->sbt,
                        static_cast<unsigned int>(activeCount), 1, 1);
            checkCuda(cudaDeviceSynchronize(), "optixLaunch shellExit");
        } else
#endif
        {
        traceSegmentExitsKernel<<<buildGrid, buildBlock>>>(
                currentEntryPos_,
                segmentRayDirections,
                hitIndices_,
                activeCount,
                outerView,
                innerView,
                params.material,
                segmentExitPos_,
                outerExitT_,
                innerEnterT_,
                innerHitFlags_);
        checkCuda(cudaGetLastError(), "traceSegmentExitsKernel launch");
        }

        uint32_t rayBatchSize = static_cast<uint32_t>(paddedActiveCount);

        buildSegmentNeuralInputsKernel<<<buildGrid, buildBlock>>>(
                currentEntryPos_,
                segmentExitPos_,
                segmentRayDirections,
                hitIndices_,
                activeCount,
                outerMin,
                outerInvExtent,
                networkInputs_,
                static_cast<int>(pointCount_),
                static_cast<int>(inputDims_));
        checkCuda(cudaGetLastError(), "buildSegmentNeuralInputsKernel launch");

        if (paddedActiveCount > activeCountSize) {
            size_t tail = paddedActiveCount - activeCountSize;
            checkCuda(cudaMemset(networkInputs_ + activeCountSize * inputDims_, 0,
                                 tail * inputDims_ * sizeof(float)),
                      "cudaMemset network inputs tail");
        }

        // Single fused encoding + MLP inference; encoding runs in FP16 throughout.
        tcnn::GPUMatrix<float> inputMatrix(networkInputs_, inputDims_, rayBatchSize);
        tcnn::GPUMatrix<__half> outputMatrix(static_cast<__half*>(outputs_), mlpOutputDims_, rayBatchSize);
        network_->inference_mixed_precision(/*stream=*/nullptr, inputMatrix, outputMatrix);

        applySegmentNeuralOutputKernel<<<buildGrid, buildBlock>>>(
                static_cast<const __half*>(outputs_),
                static_cast<int>(mlpOutputDims_),
                hitIndices_,
                activeCount,
                currentEntryPos_,
                segmentRayDirections,
                accumT_,
                innerHitFlags_,
                innerEnterT_,
                outerExitT_,
                outHitPositions,
                outHitNormals,
                outHitColors,
                outHitMaterialParams,
                outHitFlags,
                rayActiveFlags_,
                outHitDistances,
                params.material);
        checkCuda(cudaGetLastError(), "applySegmentNeuralOutputKernel launch");

        prepareNextIterationKernel<<<buildGrid, buildBlock>>>(
                segmentExitPos_,
                outerExitT_,
                segmentRayDirections,
                innerHitFlags_,
                hitIndices_,
                activeCount,
                outerView,
                params.material,
                currentEntryPos_,
                rayActiveFlags_,
                accumT_,
                innerEnterT_);
        checkCuda(cudaGetLastError(), "prepareNextIterationKernel launch");

        checkCuda(cudaMemset(hitCount_, 0, sizeof(int)), "cudaMemset hitCount");
        compactInputsKernel<<<compactGrid, compactBlock>>>(
                rayActiveFlags_,
                elementCountInt,
                hitIndices_,
                hitCount_);
        checkCuda(cudaGetLastError(), "compactInputsKernel launch");

        checkCuda(cudaMemcpy(&activeCount, hitCount_, sizeof(int), cudaMemcpyDeviceToHost),
                  "cudaMemcpy activeCount");
    }
}

void RendererNeural::render(const Vec3& camPos) {
    if (width_ <= 0 || height_ <= 0) {
        return;
    }
    if (!scene_ || !devicePixels_) {
        return;
    }

    int maxBounces = bounceCount_;
    if (maxBounces < 0) {
        maxBounces = 0;
    }

    Mesh& originalMesh = scene_->originalMesh();
    Mesh& outerShell = scene_->outerShell();
    Mesh& innerShell = scene_->innerShell();

    // Upload all meshes that might be needed.
    originalMesh.uploadToDevice();
    outerShell.uploadToDevice();
    innerShell.uploadToDevice();
    scene_->additionalMesh().uploadToDevice();

    // Select mesh for non-neural rendering (0=original, 1=inner, 2=outer).
    Mesh* classicMesh = &originalMesh;
    if (classicMeshIndex_ == 1 && innerShell.numTriangles() > 0) {
        classicMesh = &innerShell;
    } else if (classicMeshIndex_ == 2 && outerShell.numTriangles() > 0) {
        classicMesh = &outerShell;
    }

#ifdef USE_OPTIX
    if (useHardwareRT_ && optixState_) {
        // Build GAS for any mesh that does not have one yet.
        auto buildIfNeeded = [&](Mesh& m, OptixGas& gas) {
            if (m.numTriangles() > 0 && gas.handle == 0) {
                m.buildGAS(optixState_->context);
                gas.handle     = m.gasHandle();
                gas.buffer     = 0;  // buffer owned by Mesh
                gas.bufferSize = 0;
            }
        };
        buildIfNeeded(*classicMesh,             optixState_->gasClassic);
        buildIfNeeded(outerShell,               optixState_->gasOuter);
        buildIfNeeded(innerShell,               optixState_->gasInner);
        buildIfNeeded(scene_->additionalMesh(), optixState_->gasAdditional);
    }
#endif

    EnvironmentMap& environment = scene_->environment();
    environment.uploadToDevice();
    MeshDeviceView classicView = classicMesh->deviceView();
    MeshDeviceView outerView = outerShell.deviceView();
    MeshDeviceView innerView = innerShell.deviceView();
    EnvironmentDeviceView envView = environment.deviceView();
    envView.rotation = envmapRotation_ - 90.0f;  // Convert from nbvh convention

    size_t pixelCount = static_cast<size_t>(width_) * static_cast<size_t>(height_);
    int samplesPerPixel = samplesPerPixel_;
    if (samplesPerPixel <= 0) {
        samplesPerPixel = 1;
    }
    size_t elementCount = pixelCount * static_cast<size_t>(samplesPerPixel);
    size_t paddedCount = elementCount;
    if (network_) {
        size_t granularity = static_cast<size_t>(tcnn::batch_size_granularity);
        paddedCount = roundUp(elementCount, granularity);
    }
    if (!ensureNetworkBuffers(paddedCount)) {
        return;
    }
    if (!ensureAccumBuffer(pixelCount)) {
        return;
    }

    // Outer shell bounds for normalization.
    Vec3 outerMin = outerShell.boundsMin();
    Vec3 outerMax = outerShell.boundsMax();
    Vec3 outerExtent = outerMax - outerMin;
    Vec3 outerInvExtent(
            outerExtent.x != 0.0f ? 1.0f / outerExtent.x : 0.0f,
            outerExtent.y != 0.0f ? 1.0f / outerExtent.y : 0.0f,
            outerExtent.z != 0.0f ? 1.0f / outerExtent.z : 0.0f);

    // Calculate scene scale from the classic mesh bounds for scale-adaptive epsilons.
    Vec3 sceneMin = classicMesh->boundsMin();
    Vec3 sceneMax = classicMesh->boundsMax();
    Vec3 sceneExtent = sceneMax - sceneMin;
    sceneScale_ = sqrtf(sceneExtent.x * sceneExtent.x +
                        sceneExtent.y * sceneExtent.y +
                        sceneExtent.z * sceneExtent.z);
    if (sceneScale_ < 1e-6f) {
        sceneScale_ = 1.0f;  // Fallback for invalid bounds.
    }
    static bool printedOnce = false;
    if (!printedOnce) {
        printf("Scene scale: %.6f (extent: %.6f, %.6f, %.6f)\n",
               sceneScale_, sceneExtent.x, sceneExtent.y, sceneExtent.z);
        printedOnce = true;
    }

    // Camera change detection.
    bool cameraMoved = !hasLastCamera_;
    const float kEps = 1e-4f;
    if (!cameraMoved) {
        if (fabsf(camPos.x - lastCamPos_.x) > kEps ||
            fabsf(camPos.y - lastCamPos_.y) > kEps ||
            fabsf(camPos.z - lastCamPos_.z) > kEps) {
            cameraMoved = true;
        }
        if (fabsf(basis_.forward.x - lastBasis_.forward.x) > kEps ||
            fabsf(basis_.forward.y - lastBasis_.forward.y) > kEps ||
            fabsf(basis_.forward.z - lastBasis_.forward.z) > kEps ||
            fabsf(basis_.right.x - lastBasis_.right.x) > kEps ||
            fabsf(basis_.right.y - lastBasis_.right.y) > kEps ||
            fabsf(basis_.right.z - lastBasis_.right.z) > kEps ||
            fabsf(basis_.up.x - lastBasis_.up.x) > kEps ||
            fabsf(basis_.up.y - lastBasis_.up.y) > kEps ||
            fabsf(basis_.up.z - lastBasis_.up.z) > kEps ||
            fabsf(basis_.fovY - lastFovY_) > kEps) {
            cameraMoved = true;
        }
    }
    if (cameraMoved || useNeuralQuery_ != lastUseNeuralQuery_ || lambertView_ != lastLambertView_ ||
        maxBounces != lastBounceCount_ || samplesPerPixel != lastSamplesPerPixel_ ||
        classicMeshIndex_ != lastClassicMeshIndex_ || envmapRotation_ != lastEnvmapRotation_) {
        resetAccum();
    }
    lastUseNeuralQuery_ = useNeuralQuery_;
    lastLambertView_ = lambertView_;
    lastBounceCount_ = maxBounces;
    lastSamplesPerPixel_ = samplesPerPixel;
    lastClassicMeshIndex_ = classicMeshIndex_;
    lastEnvmapRotation_ = envmapRotation_;
    lastCamPos_ = camPos;
    lastBasis_ = basis_;
    lastFovY_ = basis_.fovY;
    hasLastCamera_ = true;

    const Material& material = scene_->globalMaterial();

    RenderParams params;
    params.camPos = camPos;
    params.camForward = basis_.forward;
    params.camRight = basis_.right;
    params.camUp = basis_.up;
    params.lightDir = lightDir_;
    params.outerShellMin = outerMin;
    params.outerShellInvExtent = outerInvExtent;
    params.material = material;
    params.fovY = basis_.fovY;
    params.maxRadiance = 100.0f;
    params.sceneScale = sceneScale_;
    params.maxBounces = maxBounces;
    params.width = width_;
    params.height = height_;
    params.pixelCount = static_cast<int>(pixelCount);
    params.samplesPerPixel = samplesPerPixel;
    params.sampleOffset = accumSampleCount_;

    dim3 block(8, 8);
    dim3 grid((width_ + block.x - 1) / block.x, (height_ + block.y - 1) / block.y);

    bool neuralReady = useNeuralQuery_ && network_ &&
                       outerShell.numTriangles() > 0;
    if (neuralReady) {
        traceNeuralSegmentsForRays(
                true,
                nullptr,
                nullptr,
                nullptr,
                nullptr,
                elementCount,
                params,
                outerView,
                innerView,
                outerMin,
                outerInvExtent,
                hitPositions_,
                hitNormals_,
                hitColors_,
                hitMaterialParams_,
                hitFlags_,
                hitDistances_);

        // Always trace additional mesh (empty mesh results in all misses)
        MeshDeviceView additionalView = scene_->additionalMesh().deviceView();

#ifdef USE_OPTIX
        if (useHardwareRT_ && optixState_ && optixState_->gasAdditional.handle) {
        // if (false) {
            OptixLaunchParams lp = {};
            lp.gas               = optixState_->gasAdditional.handle;
            lp.renderParams      = params;
            lp.mesh              = additionalView;
            lp.hitPositions      = additionalHitPositions_;
            lp.hitNormals        = additionalHitNormals_;
            lp.hitColors         = additionalHitColors_;
            lp.hitMaterialParams = additionalHitMaterialParams_;
            lp.hitFlags          = additionalHitFlags_;
            cuMemcpyHtoD(optixState_->dLaunchParams, &lp, sizeof(lp));
            optixState_->sbt.raygenRecord = optixState_->dRaygenRecordsBase +
                static_cast<unsigned int>(RaygenIndex::AdditionalPrimary) * sizeof(RaygenRecord);
            optixLaunch(optixState_->pipeline, nullptr,
                        optixState_->dLaunchParams, sizeof(OptixLaunchParams),
                        &optixState_->sbt,
                        static_cast<unsigned int>(params.width),
                        static_cast<unsigned int>(params.height), 1);
            checkCuda(cudaDeviceSynchronize(), "optixLaunch additionalPrimary");
            resolveHitColorsKernel<<<grid, block>>>(
                    additionalHitColors_, additionalHitMaterialParams_, additionalHitFlags_, params, additionalView);
            checkCuda(cudaGetLastError(), "resolveHitColorsKernel additionalPrimary launch");
            checkCuda(cudaDeviceSynchronize(), "resolveHitColorsKernel additionalPrimary sync");
        } else
#endif
        {
        traceAdditionalMeshPrimaryRaysKernel<<<grid, block>>>(
                additionalHitPositions_,
                additionalHitNormals_,
                additionalHitColors_,
                additionalHitMaterialParams_,
                additionalHitFlags_,
                params,
                additionalView);
        checkCuda(cudaGetLastError(), "traceAdditionalMeshPrimaryRaysKernel launch");
        checkCuda(cudaDeviceSynchronize(), "traceAdditionalMeshPrimaryRaysKernel sync");
        }

        // Always select closest hit (if additional mesh empty, shell hits win)
        selectClosestPrimaryHitKernel<<<grid, block>>>(
                hitPositions_,
                hitNormals_,
                hitColors_,
                hitMaterialParams_,
                hitFlags_,
                additionalHitPositions_,
                additionalHitNormals_,
                additionalHitColors_,
                additionalHitMaterialParams_,
                additionalHitFlags_,
                params);
        checkCuda(cudaGetLastError(), "selectClosestPrimaryHitKernel launch");
        checkCuda(cudaDeviceSynchronize(), "selectClosestPrimaryHitKernel sync");

        // 4. Path trace from neural hits using wavefront architecture.
        // (Step numbers continue from multi-segment iteration above)
        if (!lambertView_) {
            // Initialize path state from neural primary hits
            initializePathStateKernel<<<grid, block>>>(
                    pathThroughput_,
                    pathRadiance_,
                    pathActive_,
                    hitFlags_,
                    hitNormals_,
                    hitColors_,
                    params,
                    envView);
            checkCuda(cudaGetLastError(), "initializePathStateKernel launch");

            // Wavefront bounce loop for neural mode (neural segments + additional mesh)
            float* currentHitPos = hitPositions_;
            float* currentHitNormals = hitNormals_;
            float* currentHitColors = hitColors_;
            float* currentHitMaterialParams = hitMaterialParams_;
            int* currentHitFlags = hitFlags_;
            float* currentHitDistances = hitDistances_;

            for (int bounce = 1; bounce <= maxBounces; ++bounce) {
                // Sample bounce directions (Disney BRDF - shared with GT)
                sampleBounceDirectionsKernel<<<grid, block>>>(
                        currentHitPos,
                        currentHitNormals,
                        currentHitColors,
                        currentHitMaterialParams,
                        currentHitFlags,
                        currentHitDistances,
                        pathActive_,
                        params,
                        bounceOrigins_,
                        bounceDirections_,
                        bouncePdfs_,
                        bounceBRDFs_,
                        bounceDistances_);
                checkCuda(cudaGetLastError(), "sampleBounceDirectionsKernel launch");

                // Check for early termination before tracing
                // If neural distance predicts hit before exiting outer shell, terminate the ray
                checkBounceEarlyTerminationKernel<<<grid, block>>>(
                        bounceOrigins_,
                        bounceDirections_,
                        bouncePdfs_,
                        bounceDistances_,
                        pathActive_,
                        params,
                        outerView,
                        innerView);
                checkCuda(cudaGetLastError(), "checkBounceEarlyTerminationKernel launch");

                traceNeuralSegmentsForRays(
                        false,
                        bounceOrigins_,
                        bounceDirections_,
                        pathActive_,
                        bouncePdfs_,
                        elementCount,
                        params,
                        outerView,
                        innerView,
                        outerMin,
                        outerInvExtent,
                        bouncePositions_,
                        bounceNormals_,
                        bounceColors_,
                        bounceMaterialParams_,
                        bounceHitFlags_,
                        bounceDistances_);

#ifdef USE_OPTIX
                if (useHardwareRT_ && optixState_ && optixState_->gasAdditional.handle) {
                // if (false) {
                    OptixLaunchParams lp = {};
                    lp.gas               = optixState_->gasAdditional.handle;
                    lp.renderParams      = params;
                    lp.mesh              = additionalView;
                    lp.rayOrigins        = bounceOrigins_;
                    lp.rayDirections     = bounceDirections_;
                    lp.rayPdfs           = bouncePdfs_;
                    lp.hitPositions      = additionalHitPositions_;
                    lp.hitNormals        = additionalHitNormals_;
                    lp.hitColors         = additionalHitColors_;
                    lp.hitMaterialParams = additionalHitMaterialParams_;
                    lp.hitFlags          = additionalHitFlags_;
                    cuMemcpyHtoD(optixState_->dLaunchParams, &lp, sizeof(lp));
                    optixState_->sbt.raygenRecord = optixState_->dRaygenRecordsBase +
                        static_cast<unsigned int>(RaygenIndex::AdditionalBounce) * sizeof(RaygenRecord);
                    optixLaunch(optixState_->pipeline, nullptr,
                                optixState_->dLaunchParams, sizeof(OptixLaunchParams),
                                &optixState_->sbt,
                                static_cast<unsigned int>(params.width),
                                static_cast<unsigned int>(params.height), 1);
                    checkCuda(cudaDeviceSynchronize(), "optixLaunch additionalBounce");
                    resolveHitColorsKernel<<<grid, block>>>(
                            additionalHitColors_, additionalHitMaterialParams_, additionalHitFlags_, params, additionalView);
                    checkCuda(cudaGetLastError(), "resolveHitColorsKernel additionalBounce launch");
                    checkCuda(cudaDeviceSynchronize(), "resolveHitColorsKernel additionalBounce sync");
                } else
#endif
                {
                traceAdditionalMeshRaysKernel<<<grid, block>>>(
                        bounceOrigins_,
                        bounceDirections_,
                        bouncePdfs_,
                        additionalHitPositions_,
                        additionalHitNormals_,
                        additionalHitColors_,
                        additionalHitMaterialParams_,
                        additionalHitFlags_,
                        params,
                        additionalView);
                checkCuda(cudaGetLastError(), "traceAdditionalMeshRaysKernel launch");
                }

                selectClosestHitKernel<<<grid, block>>>(
                        bouncePositions_,
                        bounceNormals_,
                        bounceColors_,
                        bounceMaterialParams_,
                        bounceHitFlags_,
                        additionalHitPositions_,
                        additionalHitNormals_,
                        additionalHitColors_,
                        additionalHitMaterialParams_,
                        additionalHitFlags_,
                        bounceOrigins_,
                        params);
                checkCuda(cudaGetLastError(), "selectClosestHitKernel launch");

                // Integrate bounce results (shared with GT)
                integrateBounceKernel<<<grid, block>>>(
                        pathThroughput_,
                        pathRadiance_,
                        pathActive_,
                        bounceHitFlags_,
                        bounceDirections_,
                        bounceBRDFs_,
                        bounce,
                        params,
                        envView);
                checkCuda(cudaGetLastError(), "integrateBounceKernel launch");

                // Swap buffers for next bounce
                currentHitPos = bouncePositions_;
                currentHitNormals = bounceNormals_;
                currentHitColors = bounceColors_;
                currentHitFlags = bounceHitFlags_;
                currentHitMaterialParams = bounceMaterialParams_;
                currentHitDistances = bounceDistances_;
            }

            // Finalize and output
            finalizePathTracingKernel<<<grid, block>>>(
                    devicePixels_,
                    accum_,
                    pathRadiance_,
                    params);
            checkCuda(cudaGetLastError(), "finalizePathTracingKernel launch");
            accumSampleCount_ += static_cast<uint32_t>(samplesPerPixel);

        } else {
            lambertKernel<<<grid, block>>>(
                    devicePixels_,
                    hitNormals_,
                    hitColors_,
                    hitFlags_,
                    params,
                    envView);
            checkCuda(cudaGetLastError(), "lambertKernel launch");
            accumSampleCount_ = 0;
        }
    } else {
        // --- Ground truth mesh path tracing (wavefront architecture) ---
        // 1. Trace primary rays
#ifdef USE_OPTIX
        if (useHardwareRT_ && optixState_ && optixState_->gasClassic.handle) {
        // if (false) {
            OptixLaunchParams lp = {};
            lp.gas          = optixState_->gasClassic.handle;
            lp.renderParams = params;
            lp.mesh         = classicView;
            lp.hitPositions       = hitPositions_;
            lp.hitNormals         = hitNormals_;
            lp.hitColors          = hitColors_;
            lp.hitMaterialParams  = hitMaterialParams_;
            lp.hitFlags           = hitFlags_;
            cuMemcpyHtoD(optixState_->dLaunchParams, &lp, sizeof(lp));
            optixState_->sbt.raygenRecord = optixState_->dRaygenRecordsBase +
                static_cast<unsigned int>(RaygenIndex::PrimaryGT) * sizeof(RaygenRecord);
            optixLaunch(optixState_->pipeline, /*stream=*/nullptr,
                        optixState_->dLaunchParams, sizeof(OptixLaunchParams),
                        &optixState_->sbt,
                        static_cast<unsigned int>(params.width),
                        static_cast<unsigned int>(params.height), 1);
            checkCuda(cudaDeviceSynchronize(), "optixLaunch primaryGT");
            resolveHitColorsKernel<<<grid, block>>>(
                    hitColors_, hitMaterialParams_, hitFlags_, params, classicView);
            checkCuda(cudaGetLastError(), "resolveHitColorsKernel launch");
            checkCuda(cudaDeviceSynchronize(), "resolveHitColorsKernel sync");
        } else
#endif
        {
        intersectGroundTruthKernel<<<grid, block>>>(
                hitPositions_,
                hitNormals_,
                hitColors_,
                hitMaterialParams_,
                hitFlags_,
                params,
                classicView);
        checkCuda(cudaGetLastError(), "intersectGroundTruthKernel launch");
        checkCuda(cudaDeviceSynchronize(), "intersectGroundTruthKernel sync");
        }

        if (lambertView_) {
            lambertKernel<<<grid, block>>>(
                    devicePixels_,
                    hitNormals_,
                    hitColors_,
                    hitFlags_,
                    params,
                    envView);
            checkCuda(cudaGetLastError(), "lambertKernel launch");
            accumSampleCount_ = 0;
        } else {
            // 2. Initialize path state
            initializePathStateKernel<<<grid, block>>>(
                    pathThroughput_,
                    pathRadiance_,
                    pathActive_,
                    hitFlags_,
                    hitNormals_,
                    hitColors_,
                    params,
                    envView);
            checkCuda(cudaGetLastError(), "initializePathStateKernel launch");

            // 3. Wavefront bounce loop
            float* currentHitPos = hitPositions_;
            float* currentHitNormals = hitNormals_;
            float* currentHitColors = hitColors_;
            float* currentHitMaterialParams = hitMaterialParams_;
            int* currentHitFlags = hitFlags_;

            for (int bounce = 1; bounce <= maxBounces; ++bounce) {
                // Sample bounce directions (Disney BRDF)
                sampleBounceDirectionsKernel<<<grid, block>>>(
                        currentHitPos,
                        currentHitNormals,
                        currentHitColors,
                        currentHitMaterialParams,
                        currentHitFlags,
                        nullptr,  // No neural distances in GT mode
                        pathActive_,
                        params,
                        bounceOrigins_,
                        bounceDirections_,
                        bouncePdfs_,
                        bounceBRDFs_,
                        nullptr);
                checkCuda(cudaGetLastError(), "sampleBounceDirectionsKernel launch");

                // Trace bounce rays against GT mesh
#ifdef USE_OPTIX
                if (useHardwareRT_ && optixState_ && optixState_->gasClassic.handle) {
                // if (false) {
                    OptixLaunchParams lp = {};
                    lp.gas         = optixState_->gasClassic.handle;
                    lp.renderParams = params;
                    lp.mesh        = classicView;
                    lp.rayOrigins      = bounceOrigins_;
                    lp.rayDirections   = bounceDirections_;
                    lp.rayPdfs         = bouncePdfs_;
                    lp.hitPositions    = bouncePositions_;
                    lp.hitNormals      = bounceNormals_;
                    lp.hitColors       = bounceColors_;
                    lp.hitMaterialParams = bounceMaterialParams_;
                    lp.hitFlags        = bounceHitFlags_;
                    cuMemcpyHtoD(optixState_->dLaunchParams, &lp, sizeof(lp));
                    optixState_->sbt.raygenRecord = optixState_->dRaygenRecordsBase +
                        static_cast<unsigned int>(RaygenIndex::BounceGT) * sizeof(RaygenRecord);
                    optixLaunch(optixState_->pipeline, nullptr,
                                optixState_->dLaunchParams, sizeof(OptixLaunchParams),
                                &optixState_->sbt,
                                static_cast<unsigned int>(params.width),
                                static_cast<unsigned int>(params.height), 1);
                    checkCuda(cudaDeviceSynchronize(), "optixLaunch bounceGT");
                    resolveHitColorsKernel<<<grid, block>>>(
                            bounceColors_, bounceMaterialParams_, bounceHitFlags_, params, classicView);
                    checkCuda(cudaGetLastError(), "resolveHitColorsKernel bounceGT launch");
                    checkCuda(cudaDeviceSynchronize(), "resolveHitColorsKernel bounceGT sync");
                } else
#endif
                {
                traceGroundTruthBouncesKernel<<<grid, block>>>(
                        bounceOrigins_,
                        bounceDirections_,
                        bouncePdfs_,
                        classicView,
                        params,
                        bouncePositions_,
                        bounceNormals_,
                        bounceColors_,
                        bounceMaterialParams_,
                        bounceHitFlags_);
                checkCuda(cudaGetLastError(), "traceGroundTruthBouncesKernel launch");
                }

                // Integrate bounce results
                integrateBounceKernel<<<grid, block>>>(
                        pathThroughput_,
                        pathRadiance_,
                        pathActive_,
                        bounceHitFlags_,
                        bounceDirections_,
                        bounceBRDFs_,
                        bounce,
                        params,
                        envView);
                checkCuda(cudaGetLastError(), "integrateBounceKernel launch");

                // Swap buffers for next bounce
                currentHitPos = bouncePositions_;
                currentHitNormals = bounceNormals_;
                currentHitColors = bounceColors_;
                currentHitMaterialParams = bounceMaterialParams_;
                currentHitFlags = bounceHitFlags_;
            }

            // 4. Finalize and output
            finalizePathTracingKernel<<<grid, block>>>(
                    devicePixels_,
                    accum_,
                    pathRadiance_,
                    params);
            checkCuda(cudaGetLastError(), "finalizePathTracingKernel launch");
            accumSampleCount_ += static_cast<uint32_t>(samplesPerPixel);
        }
    }

}

// ===========================================================================
// Memory management.
// ===========================================================================

void RendererNeural::release() {
    auto freePtr = [](auto*& ptr) {
        if (ptr) {
            cudaFree(ptr);
            ptr = nullptr;
        }
    };
    freePtr(devicePixels_);
    freePtr(accum_);
    freePtr(networkInputs_);
    freePtr(hitIndices_);
    freePtr(hitCount_);
    freePtr(outerHitPositions_);
    freePtr(innerHitPositions_);
    freePtr(rayDirections_);
    freePtr(outerHitFlags_);
    freePtr(hitPositions_);
    freePtr(hitNormals_);
    freePtr(hitColors_);
    freePtr(hitMaterialParams_);
    freePtr(hitFlags_);
    freePtr(hitDistances_);
    freePtr(additionalHitPositions_);
    freePtr(additionalHitNormals_);
    freePtr(additionalHitColors_);
    freePtr(additionalHitMaterialParams_);
    freePtr(additionalHitFlags_);
    freePtr(outputs_);
    freePtr(bouncePositions_);
    freePtr(bounceNormals_);
    freePtr(bounceDirs_);
    freePtr(bounceColors_);
    freePtr(bounceMaterialParams_);
    freePtr(bounceHitFlags_);
    freePtr(bounce2Positions_);
    freePtr(bounce2Normals_);
    freePtr(bounce2Dirs_);
    freePtr(bounce2Colors_);
    freePtr(bounce2HitFlags_);
    freePtr(pathThroughput_);
    freePtr(pathRadiance_);
    freePtr(pathActive_);
    freePtr(bounceOrigins_);
    freePtr(bounceDirections_);
    freePtr(bouncePdfs_);
    freePtr(bounceBRDFs_);
    freePtr(bounceDistances_);
    freePtr(rayActiveFlags_);
    freePtr(accumT_);
    freePtr(currentEntryPos_);
    freePtr(outerExitT_);
    freePtr(innerEnterT_);
    freePtr(innerHitFlags_);
    freePtr(segmentExitPos_);
    bufferElements_ = 0;
    accumPixels_ = 0;
    accumSampleCount_ = 0;
    hasLastCamera_ = false;
}

void RendererNeural::releaseNetwork() {
    if (networkParams_) {
        cudaFree(networkParams_);
        networkParams_ = nullptr;
    }
    network_.reset();
    networkParamsBytes_ = 0;
    inputDims_ = 0;
    mlpOutputDims_ = 0;
    mlpOutputElemSize_ = 0;
}

bool RendererNeural::ensureNetworkBuffers(size_t elementCount) {
    if (elementCount == 0) {
        return false;
    }
    if (elementCount <= bufferElements_ &&
            hitPositions_ && hitNormals_ && hitColors_ && hitMaterialParams_ && hitFlags_ && hitDistances_ &&
            additionalHitPositions_ && additionalHitNormals_ && additionalHitColors_ && additionalHitMaterialParams_ && additionalHitFlags_ &&
            outerHitPositions_ && innerHitPositions_ && rayDirections_ && outerHitFlags_ &&
            networkInputs_ &&
            hitIndices_ && hitCount_ &&
            bouncePositions_ && bounceNormals_ && bounceDirs_ && bounceColors_ && bounceMaterialParams_ && bounceHitFlags_ &&
            bounce2Positions_ && bounce2Normals_ && bounce2Dirs_ && bounce2Colors_ && bounce2HitFlags_ &&
            pathThroughput_ && pathRadiance_ && pathActive_ &&
            bounceOrigins_ && bounceDirections_ && bouncePdfs_ && bounceBRDFs_ && bounceDistances_ &&
            rayActiveFlags_ && accumT_ && currentEntryPos_ &&
            outerExitT_ && innerEnterT_ && innerHitFlags_ && segmentExitPos_) {
        return true;
    }

    // Free old buffers.
    auto freePtr = [](auto*& ptr) {
        if (ptr) {
            cudaFree(ptr);
            ptr = nullptr;
        }
    };
    freePtr(networkInputs_);
    freePtr(hitIndices_);
    freePtr(hitCount_);
    freePtr(outerHitPositions_);
    freePtr(innerHitPositions_);
    freePtr(rayDirections_);
    freePtr(outerHitFlags_);
    freePtr(hitPositions_);
    freePtr(hitNormals_);
    freePtr(hitColors_);
    freePtr(hitMaterialParams_);
    freePtr(hitFlags_);
    freePtr(hitDistances_);
    freePtr(additionalHitPositions_);
    freePtr(additionalHitNormals_);
    freePtr(additionalHitColors_);
    freePtr(additionalHitMaterialParams_);
    freePtr(additionalHitFlags_);
    freePtr(outputs_);
    freePtr(bouncePositions_);
    freePtr(bounceNormals_);
    freePtr(bounceDirs_);
    freePtr(bounceColors_);
    freePtr(bounceMaterialParams_);
    freePtr(bounceHitFlags_);
    freePtr(bounce2Positions_);
    freePtr(bounce2Normals_);
    freePtr(bounce2Dirs_);
    freePtr(bounce2Colors_);
    freePtr(bounce2HitFlags_);
    freePtr(pathThroughput_);
    freePtr(pathRadiance_);
    freePtr(pathActive_);
    freePtr(bounceOrigins_);
    freePtr(bounceDirections_);
    freePtr(bouncePdfs_);
    freePtr(bounceBRDFs_);
    freePtr(bounceDistances_);
    freePtr(rayActiveFlags_);
    freePtr(accumT_);
    freePtr(currentEntryPos_);
    freePtr(outerExitT_);
    freePtr(innerEnterT_);
    freePtr(innerHitFlags_);
    freePtr(segmentExitPos_);

    size_t vec3Bytes = elementCount * 3 * sizeof(float);
    size_t intBytes = elementCount * sizeof(int);

    // Shell tracing buffers.
    checkCuda(cudaMalloc(&outerHitPositions_, vec3Bytes), "cudaMalloc outerHitPositions");
    checkCuda(cudaMalloc(&innerHitPositions_, vec3Bytes), "cudaMalloc innerHitPositions");
    checkCuda(cudaMalloc(&rayDirections_, vec3Bytes), "cudaMalloc rayDirections");
    checkCuda(cudaMalloc(&outerHitFlags_, intBytes), "cudaMalloc outerHitFlags");

    // Raw network inputs: [entry.xyz | exit.xyz | [mid.xyz] | dir.xyz] per element.
    checkCuda(cudaMalloc(&networkInputs_, elementCount * inputDims_ * sizeof(float)),
              "cudaMalloc networkInputs");

    // Compaction buffers.
    checkCuda(cudaMalloc(&hitIndices_, intBytes), "cudaMalloc hitIndices");
    checkCuda(cudaMalloc(&hitCount_, sizeof(int)), "cudaMalloc hitCount");

    // MLP output (FP16).
    if (mlpOutputDims_ > 0 && mlpOutputElemSize_ > 0) {
        size_t outputBytes = elementCount * mlpOutputDims_ * mlpOutputElemSize_;
        checkCuda(cudaMalloc(&outputs_, outputBytes), "cudaMalloc outputs");
    }

    // Primary hit buffers.
    checkCuda(cudaMalloc(&hitPositions_, vec3Bytes), "cudaMalloc hitPositions");
    checkCuda(cudaMalloc(&hitNormals_, vec3Bytes), "cudaMalloc hitNormals");
    checkCuda(cudaMalloc(&hitColors_, vec3Bytes), "cudaMalloc hitColors");
    checkCuda(cudaMalloc(&hitMaterialParams_, vec3Bytes), "cudaMalloc hitMaterialParams");
    checkCuda(cudaMalloc(&hitFlags_, intBytes), "cudaMalloc hitFlags");
    checkCuda(cudaMalloc(&hitDistances_, elementCount * sizeof(float)), "cudaMalloc hitDistances");

    // Additional mesh hit buffers (for hybrid rendering).
    checkCuda(cudaMalloc(&additionalHitPositions_, vec3Bytes), "cudaMalloc additionalHitPositions");
    checkCuda(cudaMalloc(&additionalHitNormals_, vec3Bytes), "cudaMalloc additionalHitNormals");
    checkCuda(cudaMalloc(&additionalHitColors_, vec3Bytes), "cudaMalloc additionalHitColors");
    checkCuda(cudaMalloc(&additionalHitMaterialParams_, vec3Bytes), "cudaMalloc additionalHitMaterialParams");
    checkCuda(cudaMalloc(&additionalHitFlags_, intBytes), "cudaMalloc additionalHitFlags");

    // Bounce buffers.
    checkCuda(cudaMalloc(&bouncePositions_, vec3Bytes), "cudaMalloc bouncePositions");
    checkCuda(cudaMalloc(&bounceNormals_, vec3Bytes), "cudaMalloc bounceNormals");
    checkCuda(cudaMalloc(&bounceColors_, vec3Bytes), "cudaMalloc bounceColors");
    checkCuda(cudaMalloc(&bounceMaterialParams_, vec3Bytes), "cudaMalloc bounceMaterialParams");
    checkCuda(cudaMalloc(&bounceDirs_, vec3Bytes), "cudaMalloc bounceDirs");
    checkCuda(cudaMalloc(&bounceHitFlags_, intBytes), "cudaMalloc bounceHitFlags");

    checkCuda(cudaMalloc(&bounce2Positions_, vec3Bytes), "cudaMalloc bounce2Positions");
    checkCuda(cudaMalloc(&bounce2Normals_, vec3Bytes), "cudaMalloc bounce2Normals");
    checkCuda(cudaMalloc(&bounce2Colors_, vec3Bytes), "cudaMalloc bounce2Colors");
    checkCuda(cudaMalloc(&bounce2Dirs_, vec3Bytes), "cudaMalloc bounce2Dirs");
    checkCuda(cudaMalloc(&bounce2HitFlags_, intBytes), "cudaMalloc bounce2HitFlags");

    // Path state.
    checkCuda(cudaMalloc(&pathThroughput_, elementCount * sizeof(Vec3)), "cudaMalloc pathThroughput");
    checkCuda(cudaMalloc(&pathRadiance_, elementCount * sizeof(Vec3)), "cudaMalloc pathRadiance");
    checkCuda(cudaMalloc(&pathActive_, intBytes), "cudaMalloc pathActive");

    // Wavefront buffers.
    checkCuda(cudaMalloc(&bounceOrigins_, vec3Bytes), "cudaMalloc bounceOrigins");
    checkCuda(cudaMalloc(&bounceDirections_, vec3Bytes), "cudaMalloc bounceDirections");
    checkCuda(cudaMalloc(&bouncePdfs_, elementCount * sizeof(float)), "cudaMalloc bouncePdfs");
    checkCuda(cudaMalloc(&bounceBRDFs_, vec3Bytes), "cudaMalloc bounceBRDFs");
    checkCuda(cudaMalloc(&bounceDistances_, elementCount * sizeof(float)), "cudaMalloc bounceDistances");

    // Multi-segment iteration state buffers.
    checkCuda(cudaMalloc(&rayActiveFlags_, intBytes), "cudaMalloc rayActiveFlags");
    checkCuda(cudaMalloc(&accumT_, elementCount * sizeof(float)), "cudaMalloc accumT");
    checkCuda(cudaMalloc(&currentEntryPos_, vec3Bytes), "cudaMalloc currentEntryPos");
    checkCuda(cudaMalloc(&outerExitT_, elementCount * sizeof(float)), "cudaMalloc outerExitT");
    checkCuda(cudaMalloc(&innerEnterT_, elementCount * sizeof(float)), "cudaMalloc innerEnterT");
    checkCuda(cudaMalloc(&innerHitFlags_, intBytes), "cudaMalloc innerHitFlags");
    checkCuda(cudaMalloc(&segmentExitPos_, vec3Bytes), "cudaMalloc segmentExitPos");

    bufferElements_ = elementCount;
    return true;
}

bool RendererNeural::ensureAccumBuffer(size_t pixelCount) {
    if (pixelCount == 0) {
        return false;
    }
    if (accum_ && accumPixels_ == pixelCount) {
        return true;
    }
    if (accum_) {
        cudaFree(accum_);
        accum_ = nullptr;
    }
    checkCuda(cudaMalloc(&accum_, pixelCount * sizeof(Vec3)), "cudaMalloc accum");
    checkCuda(cudaMemset(accum_, 0, pixelCount * sizeof(Vec3)), "cudaMemset accum");
    accumPixels_ = pixelCount;
    accumSampleCount_ = 0;
    return true;
}

void RendererNeural::resetAccum() {
    if (accum_ && accumPixels_ > 0) {
        checkCuda(cudaMemset(accum_, 0, accumPixels_ * sizeof(Vec3)), "cudaMemset accum");
    }
    accumSampleCount_ = 0;

    auto zeroBuffer = [](auto* ptr, size_t bytes, const char* name) {
        if (ptr && bytes > 0) {
            checkCuda(cudaMemset(ptr, 0, bytes), name);
        }
    };

    if (bufferElements_ > 0) {
        zeroBuffer(pathRadiance_, bufferElements_ * sizeof(Vec3), "cudaMemset pathRadiance");
        zeroBuffer(pathThroughput_, bufferElements_ * sizeof(Vec3), "cudaMemset pathThroughput");
        zeroBuffer(pathActive_, bufferElements_ * sizeof(int), "cudaMemset pathActive");
        zeroBuffer(hitFlags_, bufferElements_ * sizeof(int), "cudaMemset hitFlags");
        zeroBuffer(hitPositions_, bufferElements_ * 3 * sizeof(float), "cudaMemset hitPositions");
        zeroBuffer(hitNormals_, bufferElements_ * 3 * sizeof(float), "cudaMemset hitNormals");
        zeroBuffer(hitColors_, bufferElements_ * 3 * sizeof(float), "cudaMemset hitColors");
        zeroBuffer(hitMaterialParams_, bufferElements_ * 3 * sizeof(float), "cudaMemset hitMaterialParams");
        zeroBuffer(additionalHitFlags_, bufferElements_ * sizeof(int), "cudaMemset additionalHitFlags");
        zeroBuffer(additionalHitPositions_, bufferElements_ * 3 * sizeof(float), "cudaMemset additionalHitPositions");
        zeroBuffer(additionalHitNormals_, bufferElements_ * 3 * sizeof(float), "cudaMemset additionalHitNormals");
        zeroBuffer(additionalHitColors_, bufferElements_ * 3 * sizeof(float), "cudaMemset additionalHitColors");
        zeroBuffer(additionalHitMaterialParams_, bufferElements_ * 3 * sizeof(float), "cudaMemset additionalHitMaterialParams");
    }
}
